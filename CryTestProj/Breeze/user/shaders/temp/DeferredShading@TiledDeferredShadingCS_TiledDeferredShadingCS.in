/*
BgAAAGNzXzVfMAAAFgAAAFRpbGVkRGVmZXJyZWRTaGFkaW5nQ1MAAAMZIAAAAEBAIAAAAEBBIAAAAEBCIAAAAEBDIAAAAEBEIAAAAEBFIAAAAEBGIAAAAEBHIAAAAEBIIAAAAEBJIAAAAEBKIAAAAEBLIAAAAEBMIAAAAEBQIAAAAEBRIAAAAEBSIAAAAEBTIAAAAEBUIAAAAEBVIAAAAEBwIAAAAEBxIAAAAIBPIAAAAMBAIAAAAMBBIAAAAMBCASAAAAAARgEgAAAAAEDMzAAAAAAAAAAA
*/

cbuffer PER_BATCH:register(b0, space2)
{
  float4 irreg_kernel_2d[16/2];
  //ProjParams;
  float4 ForwGiIntegrationMode;
  float4 SunDir;
  float4 SSDOParams;
  float4 ScreenSize;
};
SamplerState SampStateTrilinearClamp:register(s21, space0);
Texture2DArray<float4>SpotTexArray:register(t18, space0);
Texture2DArray<float4>ShadowMaskRT:register(t4, space0);
Texture2D sceneDepthTex:register(t0, space0);
Texture2D<float4>GiDiffuseRT:register(t10, space0);
Texture2D<float4>NormalRT:register(t1, space0);
Texture2D<float4>LTCTex_2:register(t20, space0);
Texture2D<float2>ClipVolumeIndexRT:register(t8, space0);
Texture2D<float4>SSReflectionRT:register(t6, space0);
Texture2D<float4>DirectionalOccRT:register(t5, space0);
Texture2D<float4>SpecularRT:register(t2, space0);
TextureCubeArray<float4>SpecCubeArray:register(t16, space0);
Texture2D<float3>CausticsRT:register(t12, space0);
Texture2D<float4>DiffuseRT:register(t3, space0);
Texture2D<float4>EnvBRDF:register(t7, space0);
Texture2D<float4>GiSpecularRT:register(t11, space0);
Texture2D<float4>LTCTex_1:register(t19, space0);
Texture2D<float>DepthRT:register(t0, space0);
Texture2D<float4>AOColorBleedRT:register(t9, space0);
TextureCubeArray<float4>DiffuseCubeArray:register(t17, space0);
cbuffer CBPerViewGlobal:register(b0, space1)
{
  float4x4 CV_ViewProjZeroMatr;
  float4 CV_AnimGenParams;
  float4x4 CV_ViewProjMatr;
  float4x4 CV_ViewProjNearestMatr;
  float4x4 CV_InvViewProj;
  float4x4 CV_PrevViewProjMatr;
  float4x4 CV_PrevViewProjNearestMatr;
  float3x4 CV_ScreenToWorldBasis;
  float4 CV_TessInfo;
  float4 CV_WorldViewPosition;
  float4 CV_CameraRightVector;
  float4 CV_CameraFrontVector;
  float4 CV_CameraUpVector;
  float4 CV_ScreenSize;
  float4 CV_HPosScale;
  float4 CV_ProjRatio;
  float4 CV_NearestScaled;
  float4 CV_NearFarClipDist;
  float4 CV_SunLightDir;
  float4 CV_SunColor;
  float4 CV_SkyColor;
  float4 CV_FogColor;
  float4 CV_TerrainInfo;
  float4 CV_DecalZFightingRemedy;
  float4x4 CV_FrustumPlaneEquation;
  float4 CV_WindGridOffset;
  float4x4 CV_ViewMatr;
  float4x4 CV_InvViewMatr;
  float4x4 CV_ProjMatr;
  float4x4 CV_ProjMatrUnjittered;
};
cbuffer CBPerPassShadowGen:register(b5)
{
  float4 CP_ShadowGen_LightPos;
  float4 CP_ShadowGen_ViewPos;
  float4 CP_ShadowGen_DepthTestBias;
  float4 CP_ShadowGen_FrustumInfo;
  float4 CP_ShadowGen_VegetationAlphaClamp;
};
cbuffer CBPerPassCustom:register(b5)
{
  float4 CP_Custom_ViewMode;
};
cbuffer CB_SkinQuat_Cur:register(b2)
{
  float2x4 _g_SkinQuat_Cur[768];
};
cbuffer CB_SkinQuat_Prev:register(b3)
{
  float2x4 _g_SkinQuat_Prev[768];
};
uint selectCubeFace(in float3 rayVec)
{
  float3 dir=abs(rayVec);
  bool3 pmag=bool3(dir.x>dir.y,dir.y>dir.z,dir.x>dir.z);
  bool3 nmag=bool3(dir.x<=dir.y,dir.y<=dir.z,dir.x<=dir.z);
  bool3 flp=bool3(rayVec.x==dir.x,rayVec.y==dir.y,rayVec.z==dir.z);
  uint cubeFace=(pmag.x)*(pmag.z)*(0+flp.x)+(nmag.x)*(pmag.y)*(2+flp.y)+(nmag.z)*(nmag.y)*(4+flp.z);
  return cubeFace;
}
half3 GetLuminanceWeights()
{
  return half3(0.2126h,0.7152h,0.0722h);
}
half GetLuminance(half3 color)
{
  return dot(color,GetLuminanceWeights());
}
half3 DecodeColorYCC(half3 encodedCol,const bool useChrominance=true)
{
  encodedCol=half3(encodedCol.x,encodedCol.y/(127.0f/255.0f)-1,encodedCol.z/(127.0f/255.0f)-1);
  if(!useChrominance)encodedCol.yz=0;
  half3 col;
  col.r=encodedCol.x+1.402*encodedCol.z;
  col.g=dot(half3(1,-0.3441,-0.7141),encodedCol.xyz);
  col.b=encodedCol.x+1.772*encodedCol.y;
  return col*col;
}
float3 ReconstructWorldPos(int2 WPos,float linearDepth,bool bRelativeToCamera=false)
{
  float4 wposScaled=float4(WPos*linearDepth,linearDepth,bRelativeToCamera?0.0:1.0);
  return mul(CV_ScreenToWorldBasis,wposScaled);
}
float3 ReconstructWorldPos(int2 WPos,Texture2D sceneDepthTex,bool bRelativeToCamera=false)
{
  float linearDepth=sceneDepthTex.Load(int3(WPos,0)).x;
  return ReconstructWorldPos(WPos,linearDepth,bRelativeToCamera);
}
float3 GetWorldViewPos()
{
  return float3(CV_ScreenToWorldBasis[0][3],CV_ScreenToWorldBasis[1][3],CV_ScreenToWorldBasis[2][3]);
}
struct MaterialAttribsCommon
{
  half3 NormalWorld;
  half3 Albedo;
  half3 Reflectance;
  half3 Transmittance;
  half Smoothness;
  half ScatteringIndex;
  half SelfShadowingSun;
  int LightingModel;
};
MaterialAttribsCommon DecodeGBuffer(half4 bufferA,half4 bufferB,half4 bufferC)
{
  MaterialAttribsCommon attribs;
  attribs.LightingModel=(int)floor(bufferA.w*(3.0f+(255.0f/256.0f)));
  attribs.NormalWorld=normalize(bufferA.xyz*2-1);
  attribs.Albedo=bufferB.xyz*bufferB.xyz;
  attribs.Reflectance=DecodeColorYCC(bufferC.yzw,attribs.LightingModel==0);
  attribs.Smoothness=bufferC.x;
  attribs.ScatteringIndex=bufferB.w*(3.0f+(255.0f/256.0f));
  attribs.Transmittance=half3(0,0,0);
  if(attribs.LightingModel==1)
  {
    attribs.Transmittance=DecodeColorYCC(half3(frac(bufferA.w*(3.0f+(255.0f/256.0f))),bufferC.z,bufferC.w));
  }
  attribs.SelfShadowingSun=0;
  if(attribs.LightingModel==2)
  {
    attribs.SelfShadowingSun=saturate(bufferC.z/(127.0f/255.0f)-1);
  }
  return attribs;
}
half4 DecodeGBufferAlbedoAndScattering(half4 bufferB)
{
  return half4(bufferB.xyz*bufferB.xyz,bufferB.w*(3.0f+(255.0f/256.0f)));
}
float2 MapRasterToViewport(float2 normalizedRasterPos)
{
  return normalizedRasterPos;
}
struct STiledLightShadeInfo
{
  uint lightType;
  uint resIndex;
  uint shadowMaskIndex;
  uint stencilID;
  float4 posRad;
  float2 attenuationParams;
  float2 shadowParams;
  float4 color;
  float4x4 projectorMatrix;
  float4x4 shadowMatrix;
};
half smoothstep_opt(in half maxi,in half x)
{
  x=saturate(x/maxi);
  return x*x*(3.0-2.0*x);
}
half GetAttenuation(half3 L,half fInvRadius,bool bUserFalloff=false,half fFalloffMax=1.0h)
{
  half3 vDist=L*fInvRadius;
  half fFallOff=saturate(1+dot(vDist,-vDist));
  if(bUserFalloff)fFallOff=smoothstep_opt(fFalloffMax,fFallOff);
  return fFallOff;
}
half GetPhysicalLightAttenuation(half fDist,half fInvRadius,half fAttenuationBulbSize)
{
  const half radius=1/fInvRadius;
  half d=fDist;
  half fadeoutFactor=saturate((radius-d)*(fInvRadius/0.2h));
  d=max(d-fAttenuationBulbSize,0);
  half denom=1+d/fAttenuationBulbSize;
  half fAttenuation=fadeoutFactor*fadeoutFactor/(denom*denom);
  return fAttenuation;
}
half GetSpotAttenuation(half fPdotL,half fCosAngle,half fRadius)
{
  half fSpotFalloff=fCosAngle/(fPdotL+1e-6);
  half fFallOff=1.0h-pow(saturate(fSpotFalloff),fRadius);
  return fFallOff;
}
float3 MapCubeToSphere(float3 pos)
{
  float3 pos2=pos.xyz*pos.xyz;
  return pos*sqrt(1-rcp(2)*(pos2.yzx+pos2.zxy)+rcp(3)*(pos2.yzx*pos2.zxy));
}
half SmoothnessToRoughness(half smoothness)
{
  return(1.0f-smoothness)*(1.0f-smoothness);
}
half3 SpecularBRDF(half3 N,half3 V,half3 L,half m,half3 f0,half NormalizationFactor)
{
  half m2=m*m;
  half3 H=normalize(V+L);
  half NdotH=saturate(dot(N,H));
  half spec=(NdotH*m2-NdotH)*NdotH+1;
  spec=m2/(spec*spec)*NormalizationFactor;
  half NdotL=saturate(dot(N,L));
  half NdotV=abs(dot(N,V))+1e-5h;
  half Gv=NdotL*sqrt((-NdotV*m2+NdotV)*NdotV+m2);
  half Gl=NdotV*sqrt((-NdotL*m2+NdotL)*NdotL+m2);
  spec*=0.5h/(Gv+Gl);
  half f90=saturate(dot(f0,0.33333h)/0.02h);
  half3 fresnel=lerp(f0,f90,pow(1-saturate(dot(L,H)),5));
  return fresnel*spec;
}
half3 SpecularBRDF(half3 N,half3 V,half3 L,half Gloss,half3 SpecCol)
{
  half m=max(SmoothnessToRoughness(Gloss),0.001);
  return SpecularBRDF(N,V,L,m,SpecCol,1.0f);
}
static const float LTC_LUT_SIZE=64.0f;
static const float LTC_LUT_SCALE=(LTC_LUT_SIZE-1.0f)/LTC_LUT_SIZE;
static const float LTC_LUT_BIAS=0.5f/LTC_LUT_SIZE;
float3 IntegrateEdgeVec(float3 v1,float3 v2)
{
  float x=dot(v1,v2);
  float y=abs(x);
  float a=0.8543985+(0.4965155+0.0145206*y)*y;
  float b=3.4175940+(4.1616724+y)*y;
  float v=a/b;
  float theta_sintheta=(x>0.0)?v:0.5*rsqrt(max(1.0-x*x,1e-7))-v;
  return cross(v1,v2)*theta_sintheta;
}
float3 SolveCubic(float4 Coefficient)
{
  Coefficient.xyz/=Coefficient.w;
  Coefficient.yz/=3.0f;
  float A=Coefficient.w;
  float B=Coefficient.z;
  float C=Coefficient.y;
  float D=Coefficient.x;
  float3 Delta=float3(-Coefficient.z*Coefficient.z+Coefficient.y,-Coefficient.y*Coefficient.z+Coefficient.x,dot(float2(Coefficient.z,-Coefficient.y),Coefficient.xy));
  float Discriminant=dot(float2(4.0f*Delta.x,-Delta.y),Delta.zy);
  float3 RootsA,RootsD;
  float2 xlc,xsc;
  
  {
    float A_a=1.0f;
    float C_a=Delta.x;
    float D_a=-2.0f*B*Delta.x+Delta.y;
    float Theta=atan2(sqrt(Discriminant),-D_a)/3.0f;
    float x_1a=2.0f*sqrt(-C_a)*cos(Theta);
    float x_3a=2.0f*sqrt(-C_a)*cos(Theta+(2.0f/3.0f)*3.1415);
    float xl;
    if((x_1a+x_3a)>2.0f*B)xl=x_1a;
    else xl=x_3a;
    xlc=float2(xl-B,A);
  }
  
  {
    float A_d=D;
    float C_d=Delta.z;
    float D_d=-D*Delta.y+2.0f*C*Delta.z;
    float Theta=atan2(D*sqrt(Discriminant),-D_d)/3.0f;
    float x_1d=2.0f*sqrt(-C_d)*cos(Theta);
    float x_3d=2.0f*sqrt(-C_d)*cos(Theta+(2.0f/3.0f)*3.1415);
    float xs;
    if(x_1d+x_3d<2.0f*C)xs=x_1d;
    else xs=x_3d;
    xsc=float2(-D,xs+C);
  }
  float E=xlc.y*xsc.y;
  float F=-xlc.x*xsc.y-xlc.y*xsc.x;
  float G=xlc.x*xsc.x;
  float2 xmc=float2(C*F-B*G,-B*F+C*E);
  float3 Root=float3(xsc.x/xsc.y,xmc.x/xmc.y,xlc.x/xlc.y);
  if(Root.x<Root.y&&Root.x<Root.z)Root.xyz=Root.yxz;
  else if(Root.z<Root.x&&Root.z<Root.y)Root.xyz=Root.xzy;
  return Root;
}
float3 FetchDiffuseFilteredTexture(Texture2DArray<float4>texArray,float lightArrayIdx,float3 p1_,float3 p2_,float3 p3_,float3 p4_,bool useMips)
{
  float3 V1=p2_-p1_;
  float3 V2=p4_-p1_;
  float3 planeOrtho=(cross(V1,V2));
  float planeAreaSquared=dot(planeOrtho,planeOrtho);
  float planeDistxPlaneArea=dot(planeOrtho,p1_);
  float3 P=planeDistxPlaneArea*planeOrtho/planeAreaSquared-p1_;
  float dot_V1_V2=dot(V1,V2);
  float inv_dot_V1_V1=1.0f/dot(V1,V1);
  float3 V2_=V2-V1*dot_V1_V2*inv_dot_V1_V1;
  float2 Puv;
  Puv.y=dot(V2_,P)/dot(V2_,V2_);
  Puv.x=dot(V1,P)*inv_dot_V1_V1-dot_V1_V2*inv_dot_V1_V1*Puv.y;
  float d=0;
  if(useMips)
  {
    d=abs(planeDistxPlaneArea)/pow(planeAreaSquared,0.75f);
  }
  return texArray.SampleLevel(SampStateTrilinearClamp,float3(float2(0.125f,0.125f)+0.75f*Puv,lightArrayIdx),log(2048.0f*d)/log(3.0f)).r;
}
float2 LTC_Evaluate(float3 N,float3 V,float Gloss,inout float3x3 matILT,inout float3x3 matIdentity,inout float3 T1,inout float3 T2)
{
  float m=max(SmoothnessToRoughness(Gloss),0.02f);
  float NdotV=saturate(dot(N,V));
  float2 texUV=float2(m,sqrt(1.0f-NdotV));
  texUV=texUV*LTC_LUT_SCALE+LTC_LUT_BIAS;
  float4 t1=LTCTex_1.SampleLevel(SampStateTrilinearClamp,texUV,0);
  float4 t2=LTCTex_2.SampleLevel(SampStateTrilinearClamp,texUV,0);
  matILT=float3x3(t1.x,0,t1.z,0,1,0,t1.y,0,t1.w);
  matIdentity=float3x3(1,0,0,0,1,0,0,0,1);
  T1=normalize(V-N*NdotV);
  T2=cross(N,T1);
  return float2(t2.x,t2.y);
}
float3 LTC_Rectangle(float3 N,float3 P,float3x3 mat,float3 points[4],float3 T1,float3 T2,float lightArrayIdx,bool twoSided,bool behind,bool textured,Texture2DArray<float4>texArray)
{
  mat=mul(mat,float3x3(T1,T2,N));
  float3 L[4];
  L[0]=mul(mat,points[0]-P);
  L[1]=mul(mat,points[1]-P);
  L[2]=mul(mat,points[2]-P);
  L[3]=mul(mat,points[3]-P);
  float3 texturedLight=1.0f;
  if(textured)
  {
    texturedLight=FetchDiffuseFilteredTexture(texArray,lightArrayIdx,L[0],L[1],L[2],L[3],true);
  }
  float sum=0.0f;
  L[0]=normalize(L[0]);
  L[1]=normalize(L[1]);
  L[2]=normalize(L[2]);
  L[3]=normalize(L[3]);
  float3 vsum=0.0f;
  vsum+=IntegrateEdgeVec(L[0],L[1]);
  vsum+=IntegrateEdgeVec(L[1],L[2]);
  vsum+=IntegrateEdgeVec(L[2],L[3]);
  vsum+=IntegrateEdgeVec(L[3],L[0]);
  float len=length(vsum);
  float z=(behind?-vsum.z:vsum.z)/len;
  float2 uv=float2(z*0.5f+0.5f,len);
  uv=uv*LTC_LUT_SCALE+LTC_LUT_BIAS;
  float scale=LTCTex_2.SampleLevel(SampStateTrilinearClamp,uv,0).w;
  sum=len*scale;
  float3 output=float3(sum,sum,sum);
  output*=texturedLight;
  return output;
}
float3 LTC_Disk(float3 N,float3 P,float3x3 mat,float3 points[4],float3 T1,float3 T2,bool twoSided,bool behind)
{
  float3x3 R=float3x3(T1,T2,N);
  float3 L_[3];
  L_[0]=mul(R,points[0]-P);
  L_[1]=mul(R,points[1]-P);
  L_[2]=mul(R,points[2]-P);
  float3 sum=0;
  float3 C=0.5f*(L_[0]+L_[2]);
  float3 V1=0.5f*(L_[1]-L_[2]);
  float3 V2=0.5f*(L_[1]-L_[0]);
  C=mul(mat,C);
  V1=mul(mat,V1);
  V2=mul(mat,V2);
  float earlyOut=dot(cross(V1,V2),C);
  if(!twoSided&&earlyOut<1e-6)return 0.0f;
  else if(twoSided&&earlyOut<1e-6&&earlyOut>-1e-6)return 0.0f;
  float a=0;
  float b=0;
  float d11=dot(V1,V1);
  float d22=dot(V2,V2);
  float d12=dot(V1,V2);
  if(abs(d12)/sqrt(d11*d22)>0.001f)
  {
    float tr=d11+d22;
    float det=-d12*d12+d11*d22;
    det=sqrt(det);
    float u=0.5f*sqrt(tr-2.0f*det);
    float v=0.5f*sqrt(tr+2.0f*det);
    float e_max=(u+v);
    float e_min=(u-v);
    float e_max2=e_max*e_max;
    float e_min2=e_min*e_min;
    float3 V1_,V2_;
    if(d11>d22)
    {
      V1_=d12*V1+(e_max2-d11)*V2;
      V2_=d12*V1+(e_min2-d11)*V2;
    }
    else
    {
      V1_=d12*V2+(e_max2-d22)*V1;
      V2_=d12*V2+(e_min2-d22)*V1;
    }
    a=1.0f/e_max2;
    b=1.0f/e_min2;
    V1=normalize(V1_);
    V2=normalize(V2_);
  }
  else
  {
    a=1.0f/dot(V1,V1);
    b=1.0f/dot(V2,V2);
    V1*=sqrt(a);
    V2*=sqrt(b);
  }
  float3 V3=cross(V1,V2);
  if(dot(C,V3)<0.0f)V3*=-1.0f;
  float L=dot(V3,C);
  float x0=dot(V1,C)/L;
  float y0=dot(V2,C)/L;
  a*=(L*L);
  b*=(L*L);
  float c0=a*b;
  float c1=a*b*(1.0f+x0*x0+y0*y0)-a-b;
  float c2=1.0f-a*(1.0f+x0*x0)-b*(1.0f+y0*y0);
  float c3=1.0f;
  float3 roots=SolveCubic(float4(c0,c1,c2,c3));
  float e1=roots.x;
  float e2=roots.y;
  float e3=roots.z;
  float3 avgDir=float3(a*x0/(a-e2),b*y0/(b-e2),1.0f);
  float3x3 rotate=transpose(float3x3(V1,V2,V3));
  avgDir=mul(rotate,avgDir);
  avgDir=normalize(avgDir);
  float L1=sqrt(-e2/e3);
  float L2=sqrt(-e2/e1);
  float formFactor=L1*L2*rsqrt((1.0f+L1*L1)*(1.0f+L2*L2));
  float2 uv=float2(avgDir.z*0.5f+0.5f,formFactor);
  uv=uv*LTC_LUT_SCALE+LTC_LUT_BIAS;
  float scale=LTCTex_2.SampleLevel(SampStateTrilinearClamp,uv,0).w;
  sum=formFactor*scale;
  float3 output=sum;
  return output;
}
void AreaLightLTC_GGX(float3 N,float3 V,float Gloss,float3 SpecCol,float3 position,float3 lightPos,float lightArrayIdx,float4x4 lightParamMatrix,Texture2DArray<float4>texArray,inout float3 outDiffuse,inout float3 outSpecular)
{
  float3 points[4];
  points[0]=float3(lightParamMatrix[0][0],lightParamMatrix[0][1],lightParamMatrix[0][2]);
  points[1]=float3(lightParamMatrix[1][0],lightParamMatrix[1][1],lightParamMatrix[1][2]);
  points[2]=float3(lightParamMatrix[2][0],lightParamMatrix[2][1],lightParamMatrix[2][2]);
  points[3]=float3(lightParamMatrix[3][0],lightParamMatrix[3][1],lightParamMatrix[3][2]);
  uint shape=lightParamMatrix[0][3];
  bool twoSided=lightParamMatrix[1][3];
  bool textured=lightParamMatrix[2][3];
  float3 center=float3((points[0].x+points[1].x)/2,points[0].y,(points[0].z+points[2].z)/2)-position;
  float3 lightNormal=cross(points[1]-points[0],points[3]-points[0]);
  bool behindLight=dot(points[0]-position,lightNormal)<0.0f;
  if((behindLight&&!twoSided))
  {
    outDiffuse=0;
    outSpecular=0;
    return;
  }
  float3x3 matILT,matIdentity;
  float3 T1,T2;
  float2 F_G=LTC_Evaluate(N,V,Gloss,matILT,matIdentity,T1,T2);
  if(shape==1)
  {
    outDiffuse=LTC_Rectangle(N,position,matIdentity,points,T1,T2,lightArrayIdx,twoSided,behindLight,textured,texArray);
    outSpecular=LTC_Rectangle(N,position,matILT,points,T1,T2,lightArrayIdx,twoSided,behindLight,textured,texArray);
  }
  else if(shape==2)
  {
    outDiffuse=LTC_Disk(N,position,matIdentity,points,T1,T2,twoSided,behindLight);
    outSpecular=LTC_Disk(N,position,matILT,points,T1,T2,twoSided,behindLight);
  }
  float cosTheta_i=saturate(dot(center,N));
  outSpecular*=cosTheta_i*SpecCol*F_G.x+(1.0-SpecCol)*F_G.y;
}
half3 ComputeNearestLightOnRectangle(half3 vLightPoint,float4x4 mAreaLightMatr)
{
  half3 vLightDir=dot(mAreaLightMatr[0].xyz,vLightPoint.xyz)*mAreaLightMatr[0].xyz-vLightPoint.xyz;
  half2 vSurfArea=float2(dot(vLightDir.xyz,mAreaLightMatr[1].xyz),dot(vLightDir.xyz,mAreaLightMatr[2].xyz));
  half2 vSurfAreaClamp=clamp(vSurfArea.xy,-mAreaLightMatr[3].xy,mAreaLightMatr[3].xy);
  half3 vNearestPoint=mAreaLightMatr[1].xyz*vSurfAreaClamp.x+(mAreaLightMatr[2].xyz*vSurfAreaClamp.y);
  return vLightPoint.xyz+vNearestPoint.xyz;
}
half Pow5(half v)
{
  return v*v*v*v*v;
}
half BurleyBRDF(half3 NdotL,half3 NdotV,half3 VdotH,half roughness)
{
  NdotV=max(NdotV,0.1);
  half energyBias=0.5*roughness;
  half energyFactor=lerp(1,1/1.51,roughness);
  half fd90=energyBias+2.0*VdotH*VdotH*roughness;
  half scatterL=lerp(1,fd90,Pow5(1-NdotL));
  half scatterV=lerp(1,fd90,Pow5(1-NdotV));
  return scatterL*scatterV*energyFactor*NdotL;
}
half DiffuseBRDF(half3 N,half3 V,half3 L,half Gloss,half NdotL)
{
  half m=SmoothnessToRoughness(min(Gloss,1));
  half VdotH=saturate(dot(V,normalize(V+L)));
  half NdotV=abs(dot(N,V))+1e-5h;
  return BurleyBRDF(NdotL,NdotV,VdotH,m);
}
half3 ThinTranslucencyBRDF(half3 N,half3 L,half3 transmittanceColor)
{
  half w=lerp(0,0.5,GetLuminance(transmittanceColor));
  half wn=rcp((1+w)*(1+w));
  half NdotL=dot(N,L);
  half transmittance=saturate((-NdotL+w)*wn);
  half diffuse=saturate((NdotL+w)*wn);
  return transmittanceColor*transmittance+diffuse;
}
half DeriveSpecularOcclusion(half fNdotV,half aoAmount,half smoothness)
{
  return saturate(pow(fNdotV+aoAmount,smoothness)-1+aoAmount);
}
half4 DecodeHDRCubemap(half4 color)
{
  return color;
}
void CubemapBoxParallaxCorrection(inout half3 vReflVec,in half3 vPosLightDist,in half3 vBoxExtentsMin,in half3 vBoxExtentsMax,inout half fGloss)
{
  half3 vReflVecN=normalize(vReflVec.xyz);
  half3 vBoxIntersectionMax=(vPosLightDist+vBoxExtentsMax)/vReflVecN;
  half3 vBoxIntersectionMin=(vPosLightDist+vBoxExtentsMin)/vReflVecN;
  half3 vFurthestPlane=select(vReflVecN>0.F,vBoxIntersectionMax,vBoxIntersectionMin);
  half fDistance=min(min(vFurthestPlane.x,vFurthestPlane.y),vFurthestPlane.z);
  half3 vInterectionPos=-vPosLightDist;
  vReflVec=vInterectionPos+(vReflVecN*fDistance);
}
float CalcClipVolumeBlendWeight(uint nClipVolumeID,uint nClipVolumeData,float fClipVolumeBlendFactor,uint nLightStencilID)
{
  const uint nLightStencilID0=nLightStencilID&0xFF;
  const uint nLightStencilID1=nLightStencilID>>16;
  if(nLightStencilID0==0xFF)return 1.0f;
  else
  {
    if(nClipVolumeData&(1<<3))
    {
      uint nClipVolumeID0=(nClipVolumeData>>24);
      uint nClipVolumeID1=(nClipVolumeData>>16)&0xFF;
      if(nLightStencilID0==nClipVolumeID0)return fClipVolumeBlendFactor;
      else if(nLightStencilID0==nClipVolumeID1)return 1.0-fClipVolumeBlendFactor;
    }
    return(nClipVolumeID==nLightStencilID0||nClipVolumeID==nLightStencilID1)?1.0f:0.0f;
  }
  }
cbuffer CBDeferredDecal:register(b0, space2)
{
  struct
  {
    float4x4 matVolumeProj;
    float4x4 matInvVolumeProj;
    float4x4 matDecalTS;
    float4 textureRect[2];
    float4 diffuseCol;
    float4 specularCol;
    float4 mipLevels;
    float4 generalParams;
    float4 opacityParams;
  }
  cbDecal;
};
cbuffer CBSSDO:register(b0, space2)
{
  struct SSDOConstants
  {
    float4 screenSize;
    float4 nearFarClipDist;
    float4 viewSpaceParams;
    float4 ssdoParams;
    float4 hmaoParams;
  }
  cbSSDO;
};
cbuffer CBClipVolume:register(b0, space2)
{
  struct ClipVolumeConstants
  {
    float4x4 transformMatrix;
    float4 projRatioScreenScale;
    float4 blendPlane0;
    float4 blendPlane1;
  }
  cbClipVolume;
};
cbuffer CBClipVolumeVolFog:register(b0, space2)
{
  struct ClipVolumeVolFogConstants
  {
    float4x4 transformMatrix;
    uint4 sliceIndex;
  }
  cbClipVolumeVolFog;
};
cbuffer CBShadowMask:register(b0, space2)
{
  struct ShadowMaskConstants
  {
    float4x4 unitMeshTransform;
    float4 lightVolumeSphereAdjust;
    float4x4 lightShadowProj;
    float4 params;
    float4 irreg_kernel_2d[8];
    float4 vLightPos;
  }
  cbShadowMaskConstants;
};
struct STiledLightCullInfo
{
  uint volumeType;
  uint PADDING0;
  float2 depthBounds;
  float4 posRad;
  float4 volumeParams0;
  float4 volumeParams1;
  float4 volumeParams2;
};
struct STiledClipVolumeInfo
{
  uint data;
};
uint4 GetResourceIndexAndMipClamps(uint resIndex)
{
  const uint resIndexID=(resIndex&0xFFFF);
  const uint resMipClamp0=(resIndex>>16)&0xFF;
  const uint resMipClamp1=(resIndex>>24)&0xFF;
  return uint4(resIndexID,resMipClamp0,resMipClamp1,0.0f);
}
void ApplyGI(inout float3 specularAcc,inout float3 diffuseAcc,float3 diffuseForwAcc,uint2 pixelCoord,float3 surfGloss,float3 surfSpecCol,Texture2D<float4>TexGiDiffuse,Texture2D<float4>TexGiSpecular,SamplerState samplerTrilinearClamp,const int nIntegrMode,float4 fParms)
{
  if(nIntegrMode==0)
  {
    float4 vSkyLightIrradiance=TexGiDiffuse[pixelCoord];
    specularAcc*=lerp(vSkyLightIrradiance.xyz,1.f,surfGloss*GetLuminance(surfSpecCol));
    diffuseAcc*=vSkyLightIrradiance.xyz;
  }
  else if(nIntegrMode==1)
  {
    float3 diffuseIrradiance=TexGiDiffuse[pixelCoord];
    specularAcc*=lerp(min(2.f,GetLuminance(diffuseIrradiance)/(GetLuminance(diffuseAcc+diffuseForwAcc)+0.001)),1.f,saturate(surfGloss*GetLuminance(surfSpecCol)*fParms.x))*fParms.z;
    diffuseAcc=diffuseIrradiance;
  }
  else if(nIntegrMode==2)
  {
    diffuseAcc=TexGiDiffuse[pixelCoord];
    specularAcc=TexGiSpecular[pixelCoord];
  }
  }
int GetNextTileLightIndex(uint lightMask,int startIndex)
{
  uint mask=startIndex<31?~((1<<(startIndex+1))-1):0;
  return firstbitlow(lightMask&mask);
}
RWBuffer<uint>TileTranspLightMaskUAV:register(u22, space0);
RWTexture2D<float3>HDRSceneTargetUAV:register(u23, space0);
RWTexture2D<float3>DiffuseAccUAV:register(u24, space0);
Buffer<uint>TileLightMask:register(t13, space0);
StructuredBuffer<STiledLightCullInfo>TiledLightsCullInfo:register(t13, space0);
StructuredBuffer<STiledLightShadeInfo>TiledLightsShadeInfo:register(t14, space0);
StructuredBuffer<STiledClipVolumeInfo>TiledClipVolumeInfo:register(t15, space0);
groupshared uint sTileLightCount;
groupshared uint sTileLightIndices[255];
groupshared uint sTileMinZ;
groupshared uint sTileMaxZ;
groupshared uint sTileDepthMask;
groupshared uint sTileWithinProjection;
groupshared uint sTileLightMask[8];
groupshared uint sTileLightMaskCounts[8];
[numthreads(8,8,1)]void TiledDeferredShadingCS(uint3 GroupID:SV_GroupID,uint3 GroupThreadID:SV_GroupThreadID)
{
  const uint groupThreadIdx=GroupThreadID.y*8+GroupThreadID.x;
  const uint2 pixelCoord=GroupID.xy*uint2(8,8)+GroupThreadID.xy;
  float2 pixelUV=float2((pixelCoord.x+0.5)*ScreenSize.z,(pixelCoord.y+0.5)*ScreenSize.w);
  float2 linearUV=MapRasterToViewport(pixelUV);
  if(groupThreadIdx==0)
  {
    sTileLightCount=0;
    sTileWithinProjection=0;
  }
  GroupMemoryBarrierWithGroupSync();
  
  {
    uint bWithinProjection=all(linearUV.xy>0)&&all(linearUV.xy<1);
    InterlockedMax(sTileWithinProjection,bWithinProjection);
    GroupMemoryBarrierWithGroupSync();
    if(sTileWithinProjection==0)return;
  }
  float2 numTiles=ceil(ScreenSize.xy/float2(8,8));
  uint tileIdx=GroupID.y*numTiles.x+GroupID.x;
  uint bufferBaseIdx=tileIdx*8;
  if(groupThreadIdx<8)
  {
    uint lightMask=TileLightMask[bufferBaseIdx+groupThreadIdx];
    sTileLightMask[groupThreadIdx]=lightMask;
    sTileLightMaskCounts[groupThreadIdx]=countbits(lightMask);
    InterlockedAdd(sTileLightCount,sTileLightMaskCounts[groupThreadIdx]);
  }
  GroupMemoryBarrierWithGroupSync();
  if(groupThreadIdx<8)
  {
    uint offset=0;
    for(uint i=0;
    i<groupThreadIdx;
    i++)offset+=sTileLightMaskCounts[i];
    uint lightCount=0;
    int lightIndex=GetNextTileLightIndex(sTileLightMask[groupThreadIdx],-1);
    while(lightIndex>=0)
    {
      sTileLightIndices[offset+lightCount++]=groupThreadIdx*32+lightIndex;
      lightIndex=GetNextTileLightIndex(sTileLightMask[groupThreadIdx],lightIndex);
    }
    }
  GroupMemoryBarrierWithGroupSync();
  bool emptyTile=sTileLightCount==0;
  float linearZ=DepthRT[pixelCoord];
  MaterialAttribsCommon attribs=DecodeGBuffer(NormalRT[pixelCoord],DiffuseRT[pixelCoord],SpecularRT[pixelCoord]);
  float3 surfNormal=attribs.NormalWorld;
  bool surfIsTranslucent=attribs.LightingModel==1;
  float3 surfTransmittanceColor=attribs.Transmittance;
  float3 surfSpecCol=attribs.Reflectance;
  float surfGloss=attribs.Smoothness;
  float3 position=ReconstructWorldPos(pixelCoord,linearZ,true);
  float3 diffuseAcc=0;
  float3 specularAcc=0;
  int curLight=0;
  int lightIndex=sTileLightCount>0?sTileLightIndices[0]:0;
  const uint clipVolumeStencilID=ClipVolumeIndexRT[pixelCoord].x*255.0f;
  const uint clipVolumeData=TiledClipVolumeInfo[clipVolumeStencilID&63].data;
  const float clipVolumeBlendFactor=ClipVolumeIndexRT[pixelCoord].y;
  
  {
    float probeWeightSum=0;
    float3 reflVec=reflect(normalize(position),surfNormal);
    float specCubeLod=6-surfGloss*6;
    while(curLight<sTileLightCount)
    {
      int lightType=TiledLightsShadeInfo[lightIndex].lightType;
      if(lightType!=1)break;
      const float clipVolumeBlendWeight=CalcClipVolumeBlendWeight(clipVolumeStencilID,clipVolumeData,clipVolumeBlendFactor,TiledLightsShadeInfo[lightIndex].stencilID);
      [branch]if(probeWeightSum<1.0&&clipVolumeBlendWeight>0)
      {
        float3 lightVec=TiledLightsShadeInfo[lightIndex].posRad.xyz-(position+GetWorldViewPos());
        float3 tmpLightVec;
        tmpLightVec.x=dot(TiledLightsShadeInfo[lightIndex].projectorMatrix[0].xyz,lightVec);
        tmpLightVec.y=dot(TiledLightsShadeInfo[lightIndex].projectorMatrix[1].xyz,lightVec);
        tmpLightVec.z=dot(TiledLightsShadeInfo[lightIndex].projectorMatrix[2].xyz,lightVec);
        [branch]if(max(max(abs(tmpLightVec.x),abs(tmpLightVec.y)),abs(tmpLightVec.z))<1)
        {
          tmpLightVec=MapCubeToSphere(tmpLightVec);
          float4 lightColor=TiledLightsShadeInfo[lightIndex].color;
          float attenuation=GetAttenuation(tmpLightVec,1,true,TiledLightsShadeInfo[lightIndex].attenuationParams.y)*TiledLightsShadeInfo[lightIndex].attenuationParams.x;
          uint4 resIndexClamps=GetResourceIndexAndMipClamps(TiledLightsShadeInfo[lightIndex].resIndex);
          float4 diffuseProbe=DiffuseCubeArray.SampleLevel(SampStateTrilinearClamp,float4(surfNormal,resIndexClamps.x),resIndexClamps.y);
          diffuseProbe.rgb=DecodeHDRCubemap(diffuseProbe);
          [branch]if(surfIsTranslucent)
          {
            float4 diffuseProbe2=DiffuseCubeArray.SampleLevel(SampStateTrilinearClamp,float4(-surfNormal,resIndexClamps.x),resIndexClamps.y);
            diffuseProbe.rgb+=DecodeHDRCubemap(diffuseProbe2)*surfTransmittanceColor;
          }
          float probeWeight=(1-probeWeightSum)*attenuation*clipVolumeBlendWeight;
          diffuseAcc+=diffuseProbe.rgb*(lightColor.rgb*probeWeight);
          float tmpGloss=0;
          float3 tmpReflVec=reflVec;
          CubemapBoxParallaxCorrection(tmpReflVec,lightVec,TiledLightsShadeInfo[lightIndex].shadowMatrix[0].xyz,TiledLightsShadeInfo[lightIndex].shadowMatrix[1].xyz,tmpGloss);
          float4 specularProbe=SpecCubeArray.SampleLevel(SampStateTrilinearClamp,float4(tmpReflVec,resIndexClamps.x),max(specCubeLod,resIndexClamps.z));
          specularProbe.rgb=DecodeHDRCubemap(specularProbe);
          specularAcc+=specularProbe.rgb*(lightColor.rgb*probeWeight)*lightColor.a;
          probeWeightSum+=probeWeight;
        }
        }
      ++curLight;
      lightIndex=sTileLightIndices[min(curLight,255-1)];
    }
    }
  
  {
    int nIntegrMode=-1;
    ApplyGI(specularAcc,diffuseAcc,0,pixelCoord,surfGloss,surfSpecCol,GiDiffuseRT,GiSpecularRT,SampStateTrilinearClamp,nIntegrMode,ForwGiIntegrationMode);
  }
  float4 occlusionData=DirectionalOccRT[pixelCoord];
  occlusionData.xyz=occlusionData.xyz*2-1;
  
  {
    float occlDiff=saturate(1-occlusionData.a*SSDOParams.y);
    occlDiff*=occlDiff;
    float3 bleedColor=AOColorBleedRT.SampleLevel(SampStateTrilinearClamp,pixelUV,0);
    diffuseAcc*=pow(occlDiff,1-min(bleedColor*bleedColor*bleedColor*3,0.7));
    float NdotV=dot(-normalize(position),surfNormal);
    float ao=saturate(1-occlusionData.a*SSDOParams.z);
    float occlSpec=DeriveSpecularOcclusion(NdotV,max(ao*ao,0.3),surfGloss);
    specularAcc*=occlSpec;
  }
  
  {
    while(curLight<sTileLightCount)
    {
      int lightType=TiledLightsShadeInfo[lightIndex].lightType;
      if(lightType!=4)break;
      const float clipVolumeBlendWeight=CalcClipVolumeBlendWeight(clipVolumeStencilID,clipVolumeData,clipVolumeBlendFactor,TiledLightsShadeInfo[lightIndex].stencilID);
      bool skipShading=clipVolumeBlendWeight==0.0;
      [branch]if(!skipShading)
      {
        float3 lightVec=TiledLightsShadeInfo[lightIndex].posRad.xyz-(position+GetWorldViewPos());
        float lightAtt=TiledLightsShadeInfo[lightIndex].posRad.w;
        float filter=1;
        float attenuation;
        float NdotL;
        float PdotL=1;
        [branch]if(lightType==4)
        {
          lightVec=ComputeNearestLightOnRectangle(lightVec,TiledLightsShadeInfo[lightIndex].projectorMatrix);
          attenuation=GetAttenuation(lightVec,rcp(lightAtt));
          lightVec=normalize(lightVec);
          PdotL=dot(-lightVec,TiledLightsShadeInfo[lightIndex].projectorMatrix[0].xyz);
          attenuation*=GetSpotAttenuation(PdotL,TiledLightsShadeInfo[lightIndex].projectorMatrix[3].w,lightAtt);
          attenuation*=attenuation;
          NdotL=saturate(dot(surfNormal,lightVec))*saturate(PdotL);
        }
        else
        {[branch]if(TiledLightsShadeInfo[lightIndex].attenuationParams.x>0)attenuation=GetPhysicalLightAttenuation(length(lightVec),rcp(lightAtt),TiledLightsShadeInfo[lightIndex].attenuationParams.x);
          else attenuation=GetAttenuation(lightVec,rcp(lightAtt));
          lightVec=normalize(lightVec);
          NdotL=saturate(dot(surfNormal,lightVec));
          if(lightType==3)
          {
            filter=0;
            [branch]if(attenuation>0)
            {
              float4 vProjTC=mul(TiledLightsShadeInfo[lightIndex].projectorMatrix,float4(position+GetWorldViewPos(),1));
              vProjTC.xy/=vProjTC.w;
              if(vProjTC.w>0&&max(abs(vProjTC.x*2-1),abs(vProjTC.y*2-1))<1)
              {
                uint4 resIndexClamps=GetResourceIndexAndMipClamps(TiledLightsShadeInfo[lightIndex].resIndex);
                filter=SpotTexArray.SampleLevel(SampStateTrilinearClamp,float3(vProjTC.xy,resIndexClamps.x),resIndexClamps.y).x;
              }
              }
            }
          else
          {
            attenuation*=attenuation;
          }
          }
        float3 lightColor=TiledLightsShadeInfo[lightIndex].color.rgb;
        float lightOccl=0.3+0.7*(1.0-saturate(dot(lightVec,occlusionData.xyz)*SSDOParams.x));
        float3 dirFactor=select(lightColor>1,float3(NdotL,NdotL,NdotL)*lightOccl,saturate(float3(PdotL,PdotL,PdotL)));
        attenuation*=clipVolumeBlendWeight;
        float3 lightTerm=lerp(float3(1,1,1),lightColor,attenuation*filter*dirFactor);
        diffuseAcc*=lightTerm;
        specularAcc*=lightTerm;
      }
      ++curLight;
      lightIndex=sTileLightIndices[min(curLight,255-1)];
    }
    }
  
  {
    float2 envBRDF=EnvBRDF.SampleLevel(SampStateTrilinearClamp,float2(dot(-normalize(position),surfNormal),surfGloss),0).xy;
    float3 envFresnel=lerp(envBRDF.xxx,envBRDF.yyy,surfSpecCol);
    specularAcc*=envFresnel;
    float3 caustics=CausticsRT[pixelCoord];
    diffuseAcc+=caustics;
  }
  
  {
    while(curLight<sTileLightCount)
    {
      int lightType=TiledLightsShadeInfo[lightIndex].lightType;
      float3 lightVec=TiledLightsShadeInfo[lightIndex].posRad.xyz-(position+GetWorldViewPos());
      float lightAtt=TiledLightsShadeInfo[lightIndex].posRad.w;
      float3 lightVecAreaSpec;
      float attenuation;
      float PdotL=1;
      [branch]if(lightType==9)
      {
        lightVec=SunDir.xyz;
        lightVecAreaSpec=SunDir.xyz*SunDir.w;
        attenuation=(TiledClipVolumeInfo[clipVolumeStencilID].data&(1<<2))?1.0:0.0;
      }
      else
      {
        const float clipVolumeBlendWeight=CalcClipVolumeBlendWeight(clipVolumeStencilID,clipVolumeData,clipVolumeBlendFactor,TiledLightsShadeInfo[lightIndex].stencilID);
        lightVecAreaSpec=lightVec;
        attenuation=GetPhysicalLightAttenuation(length(lightVec),rcp(lightAtt),TiledLightsShadeInfo[lightIndex].attenuationParams.x)*clipVolumeBlendWeight;
        lightVec=normalize(lightVec);
      }
      float NdotL=saturate(dot(surfNormal,lightVec))*saturate(PdotL);
      [branch]if(attenuation>0&&(NdotL>0||surfIsTranslucent||lightType==8))
      {
        float lightTerm=1;
        bool shadowMap=TiledLightsShadeInfo[lightIndex].shadowParams.x>0;
        bool skipShading=false;
        [branch]if(lightType!=9)
        {[branch]if(lightType==6)
          {
            float4 vProjTC=mul(TiledLightsShadeInfo[lightIndex].projectorMatrix,float4(position+GetWorldViewPos(),1));
            vProjTC.xy/=vProjTC.w;
            [branch]if(vProjTC.w<0||max(abs(vProjTC.x*2-1),abs(vProjTC.y*2-1))>1)skipShading=true;
            else
            {
              uint4 resIndexClamps=GetResourceIndexAndMipClamps(TiledLightsShadeInfo[lightIndex].resIndex);
              lightTerm=SpotTexArray.SampleLevel(SampStateTrilinearClamp,float3(vProjTC.xy,resIndexClamps.x),resIndexClamps.y).r;
            }
            }
          else if(lightType==7)
          {
            skipShading=(TiledLightsShadeInfo[lightIndex].resIndex!=selectCubeFace(lightVec));
          }
          }
        [branch]if(!skipShading)
        {
          float4 lightColor=TiledLightsShadeInfo[lightIndex].color;
          float shadowTerm=1.0;
          [branch]if(shadowMap)
          {
            int3 sampleCoords=int3(pixelCoord,TiledLightsShadeInfo[lightIndex].shadowMaskIndex);
            shadowTerm=1-ShadowMaskRT[sampleCoords];
          }
          [branch]if(shadowTerm>0)
          {
            float lightOccl=1.0-saturate(dot(lightVec,occlusionData.xyz)*SSDOParams.x);
            lightOccl*=lightOccl;
            lightTerm*=attenuation*shadowTerm*lightOccl;
            float3 diffuseTerm=0;
            float3 specTerm=0;
            float3 diffuseTranslucency=0;
            if(lightType==8)
            {
              float3 lightPos=TiledLightsShadeInfo[lightIndex].posRad.xyz-GetWorldViewPos();
              uint4 resIndexClamps=GetResourceIndexAndMipClamps(TiledLightsShadeInfo[lightIndex].resIndex);
              AreaLightLTC_GGX(surfNormal,-normalize(position),surfGloss,surfSpecCol,position,lightPos,resIndexClamps.x,TiledLightsShadeInfo[lightIndex].projectorMatrix,SpotTexArray,diffuseTerm,specTerm);
              diffuseAcc+=(lightTerm*lightColor.rgb)*diffuseTerm;
              specularAcc+=(lightTerm*lightColor.rgb)*lightColor.a*specTerm;
            }
            else
            {
              diffuseTerm=DiffuseBRDF(surfNormal,-normalize(position),lightVec,surfGloss,NdotL);
              specTerm=SpecularBRDF(surfNormal,-normalize(position),lightVec,surfGloss,surfSpecCol);
              diffuseTranslucency=ThinTranslucencyBRDF(surfNormal,lightVec,surfTransmittanceColor);
              diffuseAcc+=(lightTerm*lightColor.rgb)*(surfIsTranslucent?diffuseTranslucency:diffuseTerm.xxx);
              specularAcc+=(lightTerm*lightColor.rgb)*lightColor.a*specTerm*NdotL;
            }
            }
          }
        }
      ++curLight;
      lightIndex=sTileLightIndices[min(curLight,255-1)];
    }
    }
  
  {
    float4 albedoSSS=DecodeGBufferAlbedoAndScattering(DiffuseRT[pixelCoord]);
    float scatteringIndex=albedoSSS.w;
    float3 surfAlbedo=albedoSSS.rgb;
    surfAlbedo*=saturate(1-GetLuminance(surfSpecCol));
    float3 finalCol=diffuseAcc*surfAlbedo+specularAcc;
    [branch]if(scatteringIndex>0)
    {
      finalCol=specularAcc;
      diffuseAcc*=floor(scatteringIndex)!=1?sqrt(surfAlbedo):1;
    }
    else
    {
      diffuseAcc=0;
    }
    DiffuseAccUAV[pixelCoord]=float3(diffuseAcc);
    HDRSceneTargetUAV[pixelCoord]=float3(finalCol);
  }
  }