/*
BgAAAHBzXzZfMAAADgAAAENvbW1vbl9aUGFzc1BTAAAEARUAAAAAQAYBAAAAAEIBAAAAAEMXAAAAAEQBAAAAQE4EAAAAQFAQAAAAQHIPHwAAAABBHwAAAEBAHwAAAEBBHwAAAEBCHwAAAEBDHwAAAEBEHwAAAEBFHwAAAEBGHwAAAEBHHwAAAEBIHwAAAEBJHwAAAEBKHwAAAEBLHwAAAEBMHwAAAEBNFR8AAAAARh8AAABAWQEAAABAWgEAAABAWxAAAABAXBAAAABAXRAAAABAXhAAAABAYB8AAABAYx8AAABAZB8AAABAZR8AAACAQB8AAACAQR8AAACAQh8AAACAQx8AAACARB8AAACARR8AAACARh8AAACARx8AAACASB8AAACAScwAAAAAAAAAAA==
*/

cbuffer PER_BATCH:register(b0, space0)
{
  float4 vfHeightDensityRampParams;
  float4 vfScatteringParams;
  float4 vfGlobalEnvProbeParams0;
  float4 vfScatteringBlendParams;
  float4 vfScatteringColor;
  float4 vfDistributionParams;
  float4 vfSamplingParams;
  float3 vfColGradDelta;
  float4 irreg_kernel_2d[16/2];
  float4 vfRampParams;
  float4 vfColGradRadial;
  float4 vfGlobalEnvProbeParams1;
  float4 vfColGradParams;
  float4 vfHeightDensityParams;
  float3 vfColGradBase;
  float4 vfDistanceParams;
  float4 vfParams;
  float4 vfScatteringSecondaryColor;
  float4 vfSunDir;
};
cbuffer PER_MATERIAL:register(b0, space2)
{
  float4 MatDifColor:packoffset(c28);
  float4 MatSpecColor:packoffset(c29);
  float3 __0bendDetailFrequency__1bendDetailLeafAmplitude__2bendDetailBranchAmplitude__3:packoffset(c38);
  float __0EmittanceMapGamma__1__2__3:packoffset(c42);
  float2 __0__1SSSIndex__2__3:packoffset(c48);
};
SamplerState ssMaterialTrilinear:register(s13, space3);
SamplerState ssPointClamp:register(s20, space3);
SamplerState ssPointWrap:register(s19, space3);
SamplerState ssMaterialAnisoHigh:register(s11, space3);
Texture2D normalsTex:register(t2, space2);
Texture2D lightmapTex:register(t5, space1);
Texture2D normalsFittingTex:register(t6, space3);
Texture2D smoothnessTex:register(t6, space2);
Texture2D diffuseTex:register(t1, space2);
Texture2D heightTex:register(t7, space2);
struct pixout_gbuffer
{
  half4 GBufferA:SV_Target0;
};
cbuffer CBPerViewGlobal:register(b0, space3)
{
  float4x4 CV_ViewProjZeroMatr;
  float4 CV_AnimGenParams;
  float4x4 CV_ViewProjMatr;
  float4x4 CV_ViewProjNearestMatr;
  float4x4 CV_InvViewProj;
  float4x4 CV_PrevViewProjMatr;
  float4x4 CV_PrevViewProjNearestMatr;
  float3x4 CV_ScreenToWorldBasis;
  float4 CV_TessInfo;
  float4 CV_WorldViewPosition;
  float4 CV_CameraRightVector;
  float4 CV_CameraFrontVector;
  float4 CV_CameraUpVector;
  float4 CV_ScreenSize;
  float4 CV_HPosScale;
  float4 CV_ProjRatio;
  float4 CV_NearestScaled;
  float4 CV_NearFarClipDist;
  float4 CV_SunLightDir;
  float4 CV_SunColor;
  float4 CV_SkyColor;
  float4 CV_FogColor;
  float4 CV_TerrainInfo;
  float4 CV_DecalZFightingRemedy;
  float4x4 CV_FrustumPlaneEquation;
  float4 CV_WindGridOffset;
  float4x4 CV_ViewMatr;
  float4x4 CV_InvViewMatr;
  float4x4 CV_ProjMatr;
  float4x4 CV_ProjMatrUnjittered;
};
cbuffer CBPerPassShadowGen:register(b5)
{
  float4 CP_ShadowGen_LightPos;
  float4 CP_ShadowGen_ViewPos;
  float4 CP_ShadowGen_DepthTestBias;
  float4 CP_ShadowGen_FrustumInfo;
  float4 CP_ShadowGen_VegetationAlphaClamp;
};
cbuffer CBPerPassCustom:register(b5)
{
  float4 CP_Custom_ViewMode;
};
cbuffer CB_SkinQuat_Cur:register(b2)
{
  float2x4 _g_SkinQuat_Cur[768];
};
cbuffer CB_SkinQuat_Prev:register(b3)
{
  float2x4 _g_SkinQuat_Prev[768];
};
half3 GetLuminanceWeights()
{
  return half3(0.2126h,0.7152h,0.0722h);
}
half GetLuminance(half3 color)
{
  return dot(color,GetLuminanceWeights());
}
half3 EncodeColorYCC(half3 col)
{
  half3 encodedCol;
  col=sqrt(col);
  encodedCol.x=dot(half3(0.299,0.587,0.114),col.rgb);
  encodedCol.y=dot(half3(-0.1687,-0.3312,0.5),col.rgb);
  encodedCol.z=dot(half3(0.5,-0.4186,-0.0813),col.rgb);
  return half3(encodedCol.x,encodedCol.y*(127.0f/255.0f)+(127.0f/255.0f),encodedCol.z*(127.0f/255.0f)+(127.0f/255.0f));
}
half4 GetTexture2DLod(Texture2D tex,SamplerState samplerState,float4 uv)
{
  return tex.SampleLevel(samplerState,uv.xy,uv.w);
}
half2 GetTexture2DLod(Texture2D<float2>tex,SamplerState samplerState,float4 uv)
{
  return tex.SampleLevel(samplerState,uv.xy,uv.w);
}
half4 GetTexture2DLod(Texture2D tex,SamplerState samplerState,float2 uv,float Lod)
{
  return tex.SampleLevel(samplerState,uv.xy,Lod);
}
half4 GetTexture2DProj(Texture2D tex,SamplerState samplerState,float4 uv)
{
  return tex.Sample(samplerState,uv.xy*rcp(uv.w));
}
half2 GetTexture2DProj(Texture2D<float2>tex,SamplerState samplerState,float4 uv)
{
  return tex.Sample(samplerState,uv.xy*rcp(uv.w));
}
half4 GetTexture2D(Texture2D tex,SamplerState samplerState,float2 uv)
{
  return tex.Sample(samplerState,uv);
}
half2 GetXYNormalMap(Texture2D bumpTex,float2 bumpTC)
{
  return GetTexture2D(bumpTex,ssMaterialAnisoHigh,bumpTC).yx;
}
half2 GetXYNormalMap(Texture2D bumpTex,SamplerState samplerState,float2 bumpTC)
{
  return GetTexture2D(bumpTex,samplerState,bumpTC).yx;
}
half3 GetNormalMap(Texture2D bumpTex,float2 bumpTC)
{
  half3 bumpNormal;
  bumpNormal.xy=GetXYNormalMap(bumpTex,bumpTC.xy);
  bumpNormal.z=sqrt(saturate(1.h+dot(bumpNormal.xy,-bumpNormal.xy)));
  return bumpNormal;
}
half3 GetNormalMap(Texture2D bumpTex,SamplerState samplerState,float2 bumpTC)
{
  half3 bumpNormal;
  bumpNormal.xy=GetXYNormalMap(bumpTex,samplerState,bumpTC.xy);
  bumpNormal.z=sqrt(saturate(1.h+dot(bumpNormal.xy,-bumpNormal.xy)));
  return bumpNormal;
}
half GetAlphaTex(Texture2D tex,float2 texTC)
{
  return GetTexture2D(tex,ssMaterialAnisoHigh,texTC.xy).a;
}
half4 GetDiffuseTex(Texture2D tex,float2 texTC)
{
  return GetTexture2D(tex,ssMaterialAnisoHigh,texTC.xy);
}
half4 GetDiffuseTexProj(Texture2D tex,float4 texTC)
{
  return GetTexture2DProj(tex,ssMaterialAnisoHigh,texTC.xyzw);
}
half2 GetDiffuseTexProj(Texture2D<float2>tex,float4 texTC)
{
  return GetTexture2DProj(tex,ssMaterialAnisoHigh,texTC.xyzw);
}
half GetHeightTex(Texture2D tex,float2 texTC)
{
  return GetTexture2D(tex,ssMaterialTrilinear,texTC.xy);
}
half GetSmoothnessTex(Texture2D tex,float2 texTC)
{
  return GetTexture2D(tex,ssMaterialTrilinear,texTC.xy).r;
}
float2 EncodeMotionVector(float2 vMotion,bool bFastEncode=false,bool bInvert=false)
{
  if(bInvert)vMotion.y*=-1.f;
  if(!bFastEncode)vMotion=sqrt(abs(vMotion))*select(vMotion.xy>0.F,float2(1,1),float2(-1,-1));
  vMotion=vMotion*0.5h+127.f/255.f;
  return vMotion.xyxy;
}
float2 OutputVelocityRT(float2 vCurrPos,float2 vPrevPos,float fAlpha=1.0f)
{
  float2 vVelocity=(vPrevPos-vCurrPos)*fAlpha;
  return float2(EncodeMotionVector(vVelocity));
}
void CompressUnsignedNormalToNormalsBuffer(inout half4 vNormal)
{
  vNormal.rgb=vNormal.rgb*2.h-1.h;
  vNormal.rgb=normalize(vNormal.rgb);
  half3 vNormalUns=abs(vNormal.rgb);
  half maxNAbs=max(vNormalUns.z,max(vNormalUns.x,vNormalUns.y));
  float2 vTexCoord=vNormalUns.z<maxNAbs?(vNormalUns.y<maxNAbs?vNormalUns.yz:vNormalUns.xz):vNormalUns.xy;
  vTexCoord=vTexCoord.x<vTexCoord.y?vTexCoord.yx:vTexCoord.xy;
  vTexCoord.y/=vTexCoord.x;
  vNormal.rgb/=maxNAbs;
  float fFittingScale=GetTexture2D(normalsFittingTex,ssPointClamp,vTexCoord).a;
  vNormal.rgb*=fFittingScale;
  vNormal.rgb=vNormal.rgb*.5h+.5h;
}
struct MaterialAttribsCommon
{
  half3 NormalWorld;
  half3 Albedo;
  half3 Reflectance;
  half3 Transmittance;
  half Smoothness;
  half ScatteringIndex;
  half SelfShadowingSun;
  int LightingModel;
};
void EncodeGBuffer(MaterialAttribsCommon attribs,out half4 bufferA,out half4 bufferB,out half4 bufferC)
{
  bufferA.xyz=attribs.NormalWorld*0.5+0.5;
  bufferA.w=0;
  CompressUnsignedNormalToNormalsBuffer(bufferA);
  bufferB.xyz=sqrt(attribs.Albedo);
  bufferB.w=0;
  bufferC.x=attribs.Smoothness;
  bufferC.yzw=EncodeColorYCC(attribs.Reflectance);
  if(attribs.LightingModel==1)
  {
    half scatteringAmount=frac(attribs.ScatteringIndex);
    bufferB.w=scatteringAmount>0.01?attribs.ScatteringIndex/(3.0f+(255.0f/256.0f)):0;
    attribs.Transmittance=EncodeColorYCC(attribs.Transmittance);
    bufferA.w=attribs.Transmittance.x;
    bufferC.zw=attribs.Transmittance.yz;
  }
  else if(attribs.LightingModel==2)
  {
    bufferC.z=attribs.SelfShadowingSun*(127.0f/255.0f)+(127.0f/255.0f);
  }
  bufferA.w=((float)attribs.LightingModel+(bufferA.w*(255.0f/256.0f)))/(3.0f+(255.0f/256.0f));
}
void EncodeMicroGBuffer(MaterialAttribsCommon attribs,inout half4 bufferA,int2 WPos)
{
  float3 normalView=mul((float3x3)CV_ViewMatr,attribs.NormalWorld);
  float2 normalEnc=normalView.xy*rsqrt(8*normalView.z+8)+0.5;
  bool bChecker0=(WPos.x&1)==(WPos.y&1);
  float3 baseColorYCC=EncodeColorYCC(attribs.Albedo);
  bufferA.xy=bChecker0?baseColorYCC.xy:baseColorYCC.xz;
  bufferA.z=bChecker0?attribs.Smoothness:normalEnc.x;
  bufferA.w=bChecker0?GetLuminance(attribs.Reflectance):normalEnc.y;
}
void SetGBufferBlending(inout half4 bufferA,inout half4 bufferB,inout half4 bufferC,half alphaNormals,half alphaDiffuse,half alphaSpecular)
{
  bufferA.w=alphaNormals;
  bufferB.w=alphaDiffuse;
  bufferC.w=alphaSpecular;
}
int GetMSAASampleNum()
{
  int nSamplesNum=0;
  return nSamplesNum;
}
float2 MapViewportToRaster(float2 normalizedViewportPos,bool bOtherEye=false)
{
  return normalizedViewportPos;
}
float GetDissolveThreshold5(int2 sc)
{
  return abs(dot(half4(0.0h,0.76h,0.5h,-1.0h),sc.xxyy % 2));
}
float GetDissolveThreshold9(int2 sc)
{
  float tm[2][4]=
  {
    {
      0.0f/8,4.0f/8,2.0f/8,6.0f/8}
    ,
    {
      3.0f/8,7.0f/8,1.0f/8,5.0f/8}
    };
  return tm[sc.y&1][sc.x&3];
}
float GetDissolveThreshold17(int2 sc)
{
  float tm[4][4]=
  {
    {
      0.0f/16,12.0f/16,3.0f/16,15.0f/16}
    ,
    {
      8.0f/16,4.0f/16,11.0f/16,7.0f/16}
    ,
    {
      2.0f/16,14.0f/16,1.0f/16,13.0f/16}
    ,
    {
      10.0f/16,6.0f/16,9.0f/16,5.0f/16}
    };
  return tm[sc.y&3][sc.x&3];
}
float GetDissolveThreshold33(int2 sc)
{
  float tm[4][8]=
  {
    {
      0.0f/32,16.0f/32,8.0f/32,24.0f/32,2.0f/32,18.0f/32,10.0f/32,26.0f/32}
    ,
    {
      12.0f/32,28.0f/32,4.0f/32,20.0f/32,14.0f/32,30.0f/32,6.0f/32,22.0f/32}
    ,
    {
      3.0f/32,19.0f/32,11.0f/32,27.0f/32,1.0f/32,17.0f/32,9.0f/32,25.0f/32}
    ,
    {
      15.0f/32,31.0f/32,7.0f/32,23.0f/32,13.0f/32,29.0f/32,5.0f/32,21.0f/32}
    };
  return tm[sc.y&3][sc.x&7];
}
float TestDissolve(float fDissolve,int2 sc,int levels=17)
{
  return 0.0f;
}
void ApplyDissolve(float fDissolve,int2 sc,int levels=17)
{}
static const float LTC_LUT_SIZE=64.0f;
static const float LTC_LUT_SCALE=(LTC_LUT_SIZE-1.0f)/LTC_LUT_SIZE;
static const float LTC_LUT_BIAS=0.5f/LTC_LUT_SIZE;
void GetMicroDetailParams(out int mdQuality,out half mdDisplacement,out half mdHeightBias,out half mdSelfShadowStrength)
{
  mdQuality=0;
  mdDisplacement=0.0h;
  mdHeightBias=1.0h;
  mdSelfShadowStrength=0.0h;
}
void GetAlphaCoverageMask(Texture2D texDiffuse,in float2 baseTC,in half fAlphaRef,inout half fDiffuseAlpha,inout uint uCoverageMask,bool bOneBitAlpha=false)
{}
cbuffer CBPerInstance:register(b0, space0)
{};
cbuffer CBPerDraw:register(b0, space0)
{
  float3x4 CD_WorldMatrix;
  float3x4 CD_PrevWorldMatrix;
  float4 CD_CustomData;
  float4 CD_CustomData1;
  float4 CD_CustomData2;
  float4 CD_LightMapScaleAndOffset;
};
float Get_SPI_Dissolve()
{
  return CD_CustomData.w;
}
struct vert2fragZ
{
  float4 WPos:SV_POSITION;
  float4 baseTC:TEXCOORD0;
  float4 vTangent:TEXCOORD1;
  float4 vBinormal:TEXCOORD2;
  float4 vNormalWS:TEXCOORD3;
  float2 lightMapUV:TEXCOORD4;
  bool bIsFrontFace:SV_IsFrontFace;
};
cbuffer CBPerPassForward:register(b5)
{
  struct
  {
    float4 vfParams;
    float4 vfRampParams;
    float4 vfSunDir;
    float3 vfColGradBase;
    float padding0;
    float3 vfColGradDelta;
    float padding1;
    float4 vfColGradParams;
    float4 vfColGradRadial;
    float4 vfShadowDarkening;
    float4 vfShadowDarkeningSunAmb;
  }
  cbFog;
  struct
  {
    float4 vfSamplingParams;
    float4 vfDistributionParams;
    float4 vfScatteringParams;
    float4 vfScatteringBlendParams;
    float4 vfScatteringColor;
    float4 vfScatteringSecondaryColor;
    float4 vfHeightDensityParams;
    float4 vfHeightDensityRampParams;
    float4 vfDistanceParams;
    float4 vfGlobalEnvProbeParams0;
    float4 vfGlobalEnvProbeParams1;
  }
  cbVoxelFog;
  struct
  {
    float4x4 TexGen0;
    float4x4 TexGen1;
    float4x4 TexGen2;
    float4x4 TexGen3;
    float4 vInvShadowMapSize;
    float4 fDepthTestBias;
    float4 fOneDivFarDist;
    float4 fKernelRadius;
    float4 CloudShadowParams;
    float4 CloudShadowAnimParams;
    float4 irreg_kernel_2d[8];
  }
  cbShadowSampling;
  struct
  {
    float4 CloudShadingColorSun;
    float4 CloudShadingColorSky;
  }
  cbClouds;
  struct
  {
    float4 IntegrationMode;
  }
  cbSVOGI;
};
half GetBlendedHeight(float2 uv,half blendLayerFactor,in float blendLayer2Tiling)
{
  half h=GetHeightTex(heightTex,uv);
  return h;
}
void ApplyDirtAndBlendLayer(vert2fragZ IN,half blendFac,inout half3 diffCol,inout half3 specCol)
{}
void ApplyVegetationTerrainColor(vert2fragZ IN,inout MaterialAttribsCommon attribs)
{}
pixout_gbuffer Common_ZPassPS(vert2fragZ IN)
{
  pixout_gbuffer OUT=(pixout_gbuffer)0;
  half fFlipNormal=1.0f;
  fFlipNormal*=IN.bIsFrontFace?1.0f:-1.0f;
  half3x3 mTangentToWS=half3x3(half3(1,0,0),half3(0,1,0),half3(0,0,1));
  mTangentToWS=half3x3(IN.vTangent.xyz,IN.vBinormal.xyz,IN.vNormalWS.xyz*fFlipNormal);
  int mdQuality;
  half mdDisplacement;
  half mdHeightBias;
  half mdSelfShadowStrength;
  GetMicroDetailParams(mdQuality,mdDisplacement,mdHeightBias,mdSelfShadowStrength);
  const float3 pomAdjustRayForNonSquareTexres=1;
  half blendFac=0;
  float blendLayer2Tiling=0;
  if(mdQuality==1)
  {}
  else if(mdQuality==2)
  {}
  else if(mdQuality==3)
  {}
  ApplyDissolve(Get_SPI_Dissolve(),(int2)IN.WPos.xy);
  MaterialAttribsCommon attribs;
  half3 vNormalTS=half3(0,0,1);
  vNormalTS=GetNormalMap(normalsTex,IN.baseTC.xy);
  half4 vDetail=0;
  attribs.NormalWorld=normalize(mTangentToWS[2]);
  attribs.NormalWorld=normalize(mul(vNormalTS,mTangentToWS));
  half fSmoothness=MatSpecColor.w;
  fSmoothness*=GetSmoothnessTex(smoothnessTex,IN.baseTC.xy);
  attribs.Smoothness=fSmoothness;
  half4 diffuseMap=GetDiffuseTex(diffuseTex,IN.baseTC.xy);
  half3 cAlbedo=diffuseMap.rgb;
  half3 cReflectance=MatSpecColor.rgb;
  ApplyDirtAndBlendLayer(IN,blendFac,cAlbedo,cReflectance);
  cAlbedo*=MatDifColor.rgb;
  attribs.Albedo=cAlbedo;
  attribs.Reflectance=cReflectance;
  attribs.LightingModel=0;
  attribs.Transmittance=0;
  attribs.ScatteringIndex=0;
  attribs.LightingModel=__0__1SSSIndex__2__3.y!=0?1:attribs.LightingModel;
  attribs.ScatteringIndex=__0__1SSSIndex__2__3.y;
  half fSelfShadowing=0;
  if(mdQuality==3||mdQuality==2||mdQuality==1)
  {
    const float2 DetailTiling=float2(1,1);
    const float3 light=normalize(mul((float3x3)mTangentToWS,CV_SunLightDir.xyz)*pomAdjustRayForNonSquareTexres);
    const float2 lightDelta=float2(light.x,light.y)*mdDisplacement*DetailTiling;
    const float2 uv=IN.baseTC.xy*DetailTiling;
    const float h0=GetBlendedHeight(uv,blendFac,blendLayer2Tiling);
    float h=h0;
    if(mdQuality==3||mdQuality==2)
    {
      h=max(0,GetBlendedHeight(uv+1.000*lightDelta,blendFac,blendLayer2Tiling));
      h=max(h,GetBlendedHeight(uv+0.875*lightDelta,blendFac,blendLayer2Tiling));
      h=max(h,GetBlendedHeight(uv+0.750*lightDelta,blendFac,blendLayer2Tiling));
      h=max(h,GetBlendedHeight(uv+0.625*lightDelta,blendFac,blendLayer2Tiling));
      h=max(h,GetBlendedHeight(uv+0.500*lightDelta,blendFac,blendLayer2Tiling));
      h=max(h,GetBlendedHeight(uv+0.375*lightDelta,blendFac,blendLayer2Tiling));
      h=max(h,GetBlendedHeight(uv+0.250*lightDelta,blendFac,blendLayer2Tiling));
      h=max(h,GetBlendedHeight(uv+0.125*lightDelta,blendFac,blendLayer2Tiling));
    }
    else
    {
      h=max(h,GetBlendedHeight(uv+1.000*lightDelta,blendFac,blendLayer2Tiling));
      h=max(h,GetBlendedHeight(uv+0.666*lightDelta,blendFac,blendLayer2Tiling));
      h=max(h,GetBlendedHeight(uv+0.333*lightDelta,blendFac,blendLayer2Tiling));
    }
    fSelfShadowing=saturate((h-h0)*mdSelfShadowStrength);
    if(mdSelfShadowStrength>0)attribs.LightingModel=2;
  }
  attribs.SelfShadowingSun=fSelfShadowing;
  ApplyVegetationTerrainColor(IN,attribs);
  EncodeMicroGBuffer(attribs,OUT.GBufferA,IN.WPos.xy);
  OUT.GBufferA=GetTexture2D(lightmapTex,ssPointWrap,IN.lightMapUV.xy*CD_LightMapScaleAndOffset.xy+CD_LightMapScaleAndOffset.zw);
  return OUT;
}