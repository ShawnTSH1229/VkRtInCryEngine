/*
BgAAAHBzXzZfMAAADAAAAE1vdGlvbkJsdXJQUwIFEAAAAEBAEAAAAEBBEAAAAEBCEAAAAIBAEAAAAIBBARAAAAAAQMwAAAAAAAAAAA==
*/

cbuffer PER_BATCH:register(b0, space1)
{
  float4 vMotionBlurParams;
};
SamplerState MoBlur_TargSampler:register(s3, space0);
SamplerState MoBlur_VelSampler:register(s4, space0);
Texture2D<float4>MoBlur_VelTiles:register(t2, space0);
Texture2D<float4>MoBlur_Vel:register(t1, space0);
Texture2D<float4>MoBlur_Targ:register(t0, space0);
cbuffer CBPerViewGlobal:register(b6)
{
  float4x4 CV_ViewProjZeroMatr;
  float4 CV_AnimGenParams;
  float4x4 CV_ViewProjMatr;
  float4x4 CV_ViewProjNearestMatr;
  float4x4 CV_InvViewProj;
  float4x4 CV_PrevViewProjMatr;
  float4x4 CV_PrevViewProjNearestMatr;
  float3x4 CV_ScreenToWorldBasis;
  float4 CV_TessInfo;
  float4 CV_WorldViewPosition;
  float4 CV_CameraRightVector;
  float4 CV_CameraFrontVector;
  float4 CV_CameraUpVector;
  float4 CV_ScreenSize;
  float4 CV_HPosScale;
  float4 CV_ProjRatio;
  float4 CV_NearestScaled;
  float4 CV_NearFarClipDist;
  float4 CV_SunLightDir;
  float4 CV_SunColor;
  float4 CV_SkyColor;
  float4 CV_FogColor;
  float4 CV_TerrainInfo;
  float4 CV_DecalZFightingRemedy;
  float4x4 CV_FrustumPlaneEquation;
  float4 CV_WindGridOffset;
  float4x4 CV_ViewMatr;
  float4x4 CV_InvViewMatr;
  float4x4 CV_ProjMatr;
  float4x4 CV_ProjMatrUnjittered;
};
cbuffer CBPerPassShadowGen:register(b5)
{
  float4 CP_ShadowGen_LightPos;
  float4 CP_ShadowGen_ViewPos;
  float4 CP_ShadowGen_DepthTestBias;
  float4 CP_ShadowGen_FrustumInfo;
  float4 CP_ShadowGen_VegetationAlphaClamp;
};
cbuffer CBPerPassCustom:register(b5)
{
  float4 CP_Custom_ViewMode;
};
cbuffer CB_SkinQuat_Cur:register(b2)
{
  float2x4 _g_SkinQuat_Cur[768];
};
cbuffer CB_SkinQuat_Prev:register(b3)
{
  float2x4 _g_SkinQuat_Prev[768];
};
half4 GetTexture2DLod(Texture2D tex,SamplerState samplerState,float4 uv)
{
  return tex.SampleLevel(samplerState,uv.xy,uv.w);
}
half2 GetTexture2DLod(Texture2D<float2>tex,SamplerState samplerState,float4 uv)
{
  return tex.SampleLevel(samplerState,uv.xy,uv.w);
}
half4 GetTexture2DLod(Texture2D tex,SamplerState samplerState,float2 uv,float Lod)
{
  return tex.SampleLevel(samplerState,uv.xy,Lod);
}
float2 DecodeMotionVector(float2 vMotionEncoded,bool bFastEncoded=false)
{
  if(bFastEncoded)
  {
    return(vMotionEncoded-127.0f/255.0f)*2.0f;
  }
  vMotionEncoded.xy=(vMotionEncoded.xy-127.f/255.f)*2.0f;
  return(vMotionEncoded.xy*vMotionEncoded.xy)*select(vMotionEncoded.xy>0.F,float2(1,1),float2(-1,-1));
}
float2 MapViewportToRaster(float2 normalizedViewportPos,bool bOtherEye=false)
{
  return normalizedViewportPos;
}
static const float LTC_LUT_SIZE=64.0f;
static const float LTC_LUT_SCALE=(LTC_LUT_SIZE-1.0f)/LTC_LUT_SIZE;
static const float LTC_LUT_BIAS=0.5f/LTC_LUT_SIZE;
struct vtxOut
{
  float4 WPos:SV_POSITION;
  float4 baseTC:TEXCOORD0;
};
float2 UnpackLengthAndDepth(float2 packedLenDepth)
{
  packedLenDepth.x=(packedLenDepth.x*packedLenDepth.x)/32.0f;
  packedLenDepth.y=packedLenDepth.y*255.0f;
  return packedLenDepth;
}
float MBSampleWeight(float centerDepth,float sampleDepth,float centerVelLen,float sampleVelLen,float sampleIndex,float lenToSampleIndex)
{
  const float2 depthCompare=saturate(0.5f+float2(1,-1)*(sampleDepth-centerDepth));
  const float2 spreadCompare=saturate(1+lenToSampleIndex*float2(centerVelLen,sampleVelLen)-sampleIndex);
  return dot(depthCompare.xy,spreadCompare.xy);
}
float3 NRand3(float2 seed)
{
  return frac(sin(dot(seed.xy,float2(34.483,89.637)))*float3(29156.4765,38273.5639,47843.7546));
}
float4 MotionBlurPS(vtxOut IN):SV_Target0
{
  const int numSamples=14;
  const float weightStep=1.0/((float)numSamples);
  const int2 pixQuadIdx=fmod(IN.WPos.xy,2);
  float samplingDither=(-0.25+2.0*0.25*pixQuadIdx.x)*(-1.0+2.0*pixQuadIdx.y);
  float2 tileBorderDist=abs(frac(IN.WPos.xy*vMotionBlurParams.xy)-0.5)*2;
  tileBorderDist*=(samplingDither<0)?float2(1,0):float2(0,1);
  float rndValue=NRand3(IN.baseTC.xy).x-0.5;
  float2 tileOffset=tileBorderDist*rndValue;
  float2 screenTC=MapViewportToRaster(IN.baseTC.xy);
  float3 maxVel=GetTexture2DLod(MoBlur_VelTiles,MoBlur_VelSampler,float4(screenTC.xy+tileOffset*vMotionBlurParams.xy,0,0));
  maxVel.xy=DecodeMotionVector(maxVel.xy);
  const float2 blurStep=maxVel.xy*weightStep;
  const float2 centerLenDepth=UnpackLengthAndDepth(GetTexture2DLod(MoBlur_Vel,MoBlur_VelSampler,float4(screenTC.xy,0,0)).zw);
  const float4 sampleCenter=GetTexture2DLod(MoBlur_Targ,MoBlur_TargSampler,float4(screenTC.xy,0,0));
  float4 acc=float4(0,0,0,0);
  [unroll]for(int s=0;
  s<numSamples/2;
  ++s)
  {
    const float curStep=(s+samplingDither);
    float2 tc0=IN.baseTC.xy+blurStep*curStep;
    float2 tc1=IN.baseTC.xy-blurStep*curStep;
    tc0=MapViewportToRaster(tc0);
    tc1=MapViewportToRaster(tc1);
    float2 lenDepth0=UnpackLengthAndDepth(GetTexture2DLod(MoBlur_Vel,MoBlur_VelSampler,float4(tc0.xy,0,0)).zw);
    float2 lenDepth1=UnpackLengthAndDepth(GetTexture2DLod(MoBlur_Vel,MoBlur_VelSampler,float4(tc1.xy,0,0)).zw);
    float weight0=MBSampleWeight(centerLenDepth.y,lenDepth0.y,centerLenDepth.x,lenDepth0.x,s,1.0/length(blurStep));
    float weight1=MBSampleWeight(centerLenDepth.y,lenDepth1.y,centerLenDepth.x,lenDepth1.x,s,1.0/length(blurStep));
    const bool2 mirror=bool2(lenDepth0.y>lenDepth1.y,lenDepth1.x>lenDepth0.x);
    weight0=all(mirror)?weight1:weight0;
    weight1=any(mirror)?weight1:weight0;
    acc+=float4(GetTexture2DLod(MoBlur_Targ,MoBlur_TargSampler,float4(tc0.xy,0,0)).rgb,1.0f)*weight0;
    acc+=float4(GetTexture2DLod(MoBlur_Targ,MoBlur_TargSampler,float4(tc1.xy,0,0)).rgb,1.0f)*weight1;
  }
  acc.rgba*=weightStep;
  return acc;
}