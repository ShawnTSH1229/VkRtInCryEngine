/*
BgAAAHBzXzZfMAAAEAAAAFNTRE9fU2FtcGxpbmdfUFMDBhAAAABAQBAAAABAQRAAAABAQxAAAABARRAAAACAQBAAAACAQQEQAAAAAEABEQAAAABGAAAAAAAAAAA=
*/

cbuffer PER_BATCH:register(b0, space1)
{
  float4 PS_NearFarClipDist;
  float4 PS_ScreenSize;
};
SamplerState SSDOSamp_depthSS:register(s4, space0);
Texture2D<float4>SSDOSamp_LinZ:register(t1, space0);
Texture2D<float4>SSDOSamp_LinZSc:register(t3, space0);
Texture2D<float4>SSDOSamp_Norms:register(t0, space0);
Texture2D<float4>SSDOSamp_HMAODepth:register(t11);
Texture2D<float4>SSDOSamp_HMAO:register(t12);
struct pixout
{
  half4 Color:SV_Target0;
};
cbuffer CBPerViewGlobal:register(b0, space2)
{
  float4x4 CV_ViewProjZeroMatr;
  float4 CV_AnimGenParams;
  float4x4 CV_ViewProjMatr;
  float4x4 CV_ViewProjNearestMatr;
  float4x4 CV_InvViewProj;
  float4x4 CV_PrevViewProjMatr;
  float4x4 CV_PrevViewProjNearestMatr;
  float3x4 CV_ScreenToWorldBasis;
  float4 CV_TessInfo;
  float4 CV_WorldViewPosition;
  float4 CV_CameraRightVector;
  float4 CV_CameraFrontVector;
  float4 CV_CameraUpVector;
  float4 CV_ScreenSize;
  float4 CV_HPosScale;
  float4 CV_ProjRatio;
  float4 CV_NearestScaled;
  float4 CV_NearFarClipDist;
  float4 CV_SunLightDir;
  float4 CV_SunColor;
  float4 CV_SkyColor;
  float4 CV_FogColor;
  float4 CV_TerrainInfo;
  float4 CV_DecalZFightingRemedy;
  float4x4 CV_FrustumPlaneEquation;
  float4 CV_WindGridOffset;
  float4x4 CV_ViewMatr;
  float4x4 CV_InvViewMatr;
  float4x4 CV_ProjMatr;
  float4x4 CV_ProjMatrUnjittered;
};
cbuffer CBPerPassShadowGen:register(b5)
{
  float4 CP_ShadowGen_LightPos;
  float4 CP_ShadowGen_ViewPos;
  float4 CP_ShadowGen_DepthTestBias;
  float4 CP_ShadowGen_FrustumInfo;
  float4 CP_ShadowGen_VegetationAlphaClamp;
};
cbuffer CBPerPassCustom:register(b5)
{
  float4 CP_Custom_ViewMode;
};
cbuffer CB_SkinQuat_Cur:register(b2)
{
  float2x4 _g_SkinQuat_Cur[768];
};
cbuffer CB_SkinQuat_Prev:register(b3)
{
  float2x4 _g_SkinQuat_Prev[768];
};
half4 GetTexture2DLod(Texture2D tex,SamplerState samplerState,float4 uv)
{
  return tex.SampleLevel(samplerState,uv.xy,uv.w);
}
half2 GetTexture2DLod(Texture2D<float2>tex,SamplerState samplerState,float4 uv)
{
  return tex.SampleLevel(samplerState,uv.xy,uv.w);
}
half4 GetTexture2DLod(Texture2D tex,SamplerState samplerState,float2 uv,float Lod)
{
  return tex.SampleLevel(samplerState,uv.xy,Lod);
}
half4 GetTexture2D(Texture2D tex,SamplerState samplerState,float2 uv)
{
  return tex.Sample(samplerState,uv);
}
float GetLinearDepth(float fDevDepth,bool bScaled=false)
{
  return fDevDepth*(bScaled?PS_NearFarClipDist.y:1.0f);
}
float GetLinearDepth(Texture2D depthTexture,int2 vPixCoord,bool bScaled=false)
{
  float fDepth=depthTexture.Load(int3(vPixCoord,0)).x;
  return GetLinearDepth(fDepth,bScaled);
}
float GetLinearDepth(Texture2D depthTexture,float2 ScreenTC,bool bScaled=false)
{
  int2 vPixCoord=int2(ScreenTC*PS_ScreenSize.xy);
  return GetLinearDepth(depthTexture,vPixCoord,bScaled);
}
half3 DecodeGBufferNormal(half4 bufferA)
{
  return normalize(bufferA.xyz*2-1);
}
float2 MapViewportToRaster(float2 normalizedViewportPos,bool bOtherEye=false)
{
  return normalizedViewportPos;
}
static const float LTC_LUT_SIZE=64.0f;
static const float LTC_LUT_SCALE=(LTC_LUT_SIZE-1.0f)/LTC_LUT_SIZE;
static const float LTC_LUT_BIAS=0.5f/LTC_LUT_SIZE;
struct vtxOut
{
  float4 WPos:SV_POSITION;
  float4 baseTC:TEXCOORD0;
};
cbuffer CBDeferredDecal:register(b0, space1)
{
  struct
  {
    float4x4 matVolumeProj;
    float4x4 matInvVolumeProj;
    float4x4 matDecalTS;
    float4 textureRect[2];
    float4 diffuseCol;
    float4 specularCol;
    float4 mipLevels;
    float4 generalParams;
    float4 opacityParams;
  }
  cbDecal;
};
cbuffer CBSSDO:register(b0, space1)
{
  struct SSDOConstants
  {
    float4 screenSize;
    float4 nearFarClipDist;
    float4 viewSpaceParams;
    float4 ssdoParams;
    float4 hmaoParams;
  }
  cbSSDO;
};
half4 SSDOFetchDepths(Texture2D depthTex,SamplerState ssDepth,half4 tc[2],uint component)
{
  return half4(GetTexture2DLod(depthTex,ssDepth,half4(tc[0].xy,0,0))[component],GetTexture2DLod(depthTex,ssDepth,half4(tc[0].zw,0,0))[component],GetTexture2DLod(depthTex,ssDepth,half4(tc[1].xy,0,0))[component],GetTexture2DLod(depthTex,ssDepth,half4(tc[1].zw,0,0))[component]);
}
pixout SSDO_Sampling_PS(vtxOut IN)
{
  pixout OUT=(pixout)0;
  static const int samplesNum=8;
  static const float2 kernel[8]=
  {
    half2(-0.14,-0.02),half2(-0.04,0.24),half2(0.36,0.08),half2(0.26,-0.4),half2(-0.44,-0.34),half2(-0.52,0.4),half2(0.3,0.68),half2(0.84,-0.32)};
  float4 screenTC;
  screenTC.xy=IN.WPos.xy*cbSSDO.screenSize.zw;
  screenTC.zw=IN.WPos.xy*0.25;
  float2 linearUV=IN.baseTC.xy;
  float fCenterDepth=GetLinearDepth(SSDOSamp_LinZ,int2(linearUV*cbSSDO.screenSize.xy));
  if(fCenterDepth==1.0f)discard;
  float3 vReceiverPos=float3(linearUV.xy*cbSSDO.viewSpaceParams.xy+cbSSDO.viewSpaceParams.zw,1)*fCenterDepth*cbSSDO.nearFarClipDist.y;
  float maxRadius=cbSSDO.ssdoParams.w;
  if(int(IN.WPos.x)&1)maxRadius*=0.5;
  if(int(IN.WPos.y)&1)maxRadius*=0.5;
  const half2 radius0=clamp(cbSSDO.ssdoParams.xy*0.15/fCenterDepth,cbSSDO.ssdoParams.z,maxRadius);
  const half2 radius1=clamp(cbSSDO.ssdoParams.xy/fCenterDepth,cbSSDO.ssdoParams.z,maxRadius);
  const half jitterIndex=dot(frac(screenTC.zw),half2(1,0.25));
  half2 vJitterSinCos=half2(sin(6.2831*jitterIndex),cos(6.2831*jitterIndex));
  const half2x2 mSampleRotMat=
  {
    vJitterSinCos.y,vJitterSinCos.x,-vJitterSinCos.x,vJitterSinCos.y};
  float2 rotatedKernel[samplesNum];
  [unroll]for(int i=0;
  i<samplesNum;
  i+=4)
  {
    rotatedKernel[i+0]=mul(kernel[i+0].xy,mSampleRotMat);
    rotatedKernel[i+1]=mul(kernel[i+1].xy,mSampleRotMat);
    rotatedKernel[i+2]=mul(kernel[i+2].xy,mSampleRotMat);
    rotatedKernel[i+3]=mul(kernel[i+3].xy,mSampleRotMat);
  }
  half3 vNormal=DecodeGBufferNormal(GetTexture2D(SSDOSamp_Norms,SSDOSamp_depthSS,screenTC.xy));
  half3 vNormalVS=normalize(mul(CV_ViewMatr,half4(vNormal,0)).xyz)*float3(1,-1,-1);
  half4 sh2=0;
  [unroll]for(int i=0;
  i<samplesNum;
  i+=4)
  {
    const bool narrowBand=i<4;
    const half2 radius=narrowBand?radius0:radius1;
    half4 vSampleUV[2];
    vSampleUV[0].xy=linearUV.xy+rotatedKernel[i+0].xy*radius;
    vSampleUV[0].zw=linearUV.xy+rotatedKernel[i+1].xy*radius;
    vSampleUV[1].xy=linearUV.xy+rotatedKernel[i+2].xy*radius;
    vSampleUV[1].zw=linearUV.xy+rotatedKernel[i+3].xy*radius;
    half4 vSampleTC[2];
    vSampleTC[0].xy=MapViewportToRaster(vSampleUV[0].xy);
    vSampleTC[0].zw=MapViewportToRaster(vSampleUV[0].zw);
    vSampleTC[1].xy=MapViewportToRaster(vSampleUV[1].xy);
    vSampleTC[1].zw=MapViewportToRaster(vSampleUV[1].zw);
    half4 fLinearDepthTap=SSDOFetchDepths(SSDOSamp_LinZSc,SSDOSamp_depthSS,vSampleTC,3)+0.0000001;
    fLinearDepthTap*=cbSSDO.nearFarClipDist.y;
    float3 vEmitterPos[4];
    vEmitterPos[0]=float3(vSampleUV[0].xy*cbSSDO.viewSpaceParams.xy+cbSSDO.viewSpaceParams.zw,1)*fLinearDepthTap.x;
    vEmitterPos[1]=float3(vSampleUV[0].zw*cbSSDO.viewSpaceParams.xy+cbSSDO.viewSpaceParams.zw,1)*fLinearDepthTap.y;
    vEmitterPos[2]=float3(vSampleUV[1].xy*cbSSDO.viewSpaceParams.xy+cbSSDO.viewSpaceParams.zw,1)*fLinearDepthTap.z;
    vEmitterPos[3]=float3(vSampleUV[1].zw*cbSSDO.viewSpaceParams.xy+cbSSDO.viewSpaceParams.zw,1)*fLinearDepthTap.w;
    half3 vSample[4];
    vSample[0]=vEmitterPos[0]-vReceiverPos;
    vSample[1]=vEmitterPos[1]-vReceiverPos;
    vSample[2]=vEmitterPos[2]-vReceiverPos;
    vSample[3]=vEmitterPos[3]-vReceiverPos;
    half4 fVecLenSqr=half4(dot(vSample[0],vSample[0]),dot(vSample[1],vSample[1]),dot(vSample[2],vSample[2]),dot(vSample[3],vSample[3]));
    vSample[0]=normalize(vSample[0]);
    vSample[1]=normalize(vSample[1]);
    vSample[2]=normalize(vSample[2]);
    vSample[3]=normalize(vSample[3]);
    const half radiusWS=(radius.x*fCenterDepth)*cbSSDO.viewSpaceParams.x*cbSSDO.nearFarClipDist.y;
    const half emitterScale=narrowBand?0.5:2.5;
    const half emitterArea=(emitterScale*3.1415*radiusWS*radiusWS)/(float)(samplesNum/2);
    half4 fNdotSamp=half4(dot(vNormalVS,vSample[0]),dot(vNormalVS,vSample[1]),dot(vNormalVS,vSample[2]),dot(vNormalVS,vSample[3]));
    half4 fObscurance=emitterArea*saturate(fNdotSamp)/(fVecLenSqr+emitterArea);
    sh2.w+=dot(fObscurance,1.h);
    sh2.xyz+=fObscurance.x*vSample[0]+fObscurance.y*vSample[1]+fObscurance.z*vSample[2]+fObscurance.w*vSample[3];
  }
  sh2.xyz=mul(CV_InvViewMatr,half4(sh2.xyz*float3(1,-1,-1),0)).xyz;
  const half fNormFac=0.15;
  sh2.xyzw*=fNormFac;
  OUT.Color.rgb=sh2.xyz*0.5+0.5;
  OUT.Color.a=sh2.w;
  return OUT;
}