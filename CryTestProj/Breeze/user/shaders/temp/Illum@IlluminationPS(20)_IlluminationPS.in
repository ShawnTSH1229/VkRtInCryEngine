/*
BgAAAHBzXzZfMAAADgAAAElsbHVtaW5hdGlvblBTAAAEARUAAAAAQAYBAAAAAEIBAAAAAEMXAAAAAEQBAAAAQE4EAAAAQFAQAAAAQHIPHwAAAABBHwAAAEBAHwAAAEBBHwAAAEBCHwAAAEBDHwAAAEBEHwAAAEBFHwAAAEBGHwAAAEBHHwAAAEBIHwAAAEBJHwAAAEBKHwAAAEBLHwAAAEBMHwAAAEBNLx8AAAAARR8AAAAARh8AAABAUR8AAABAUh8AAABAUx8AAABAVB8AAABAVR8AAABAVh8AAABAVx8AAABAWB8AAABAWR8AAABAWh8AAABAWx8AAABAXB8AAABAXR8AAABAXh8AAABAYB8AAABAYR8AAABAYh8AAABAYx8AAABAZB8AAABAZR8AAABAZh8AAABAZx8AAABAaB8AAABAaR8AAABAah8AAABAax8AAABAbB8AAABAbR8AAABAbh8AAABAbx8AAABAcB8AAABAcR8AAACAQB8AAACAQR8AAACAQh8AAACAQx8AAACARB8AAACARR8AAACARh8AAACARx8AAACASB8AAACASR8AAACASh8AAACASx8AAACAT8wAAAAAAAAAAA==
*/

cbuffer PER_BATCH:register(b0, space0)
{
  float4 vfHeightDensityRampParams;
  float4 vfScatteringParams;
  float4 vfGlobalEnvProbeParams0;
  float4 vfScatteringBlendParams;
  float4 vfScatteringColor;
  float4 vfDistributionParams;
  float4 vfSamplingParams;
  float3 vfColGradDelta;
  float4 irreg_kernel_2d[16/2];
  float4 vfRampParams;
  float4 vfColGradRadial;
  float4 vfGlobalEnvProbeParams1;
  float4 vfColGradParams;
  float4 vfHeightDensityParams;
  float3 vfColGradBase;
  float4 vfDistanceParams;
  float4 vfParams;
  float4 vfTimeParams;
  float4 vfScatteringSecondaryColor;
  float4 vfSunDir;
};
cbuffer PER_MATERIAL:register(b0, space2)
{
  float4 MatDifColor:packoffset(c28);
  float4 MatSpecColor:packoffset(c29);
  float4 MatEmissiveColor:packoffset(c30);
  float4 CM_DetailTilingAndAlphaRef:packoffset(c36);
  float3 __0bendDetailFrequency__1bendDetailLeafAmplitude__2bendDetailBranchAmplitude__3:packoffset(c38);
  float __0EmittanceMapGamma__1__2__3:packoffset(c42);
  float2 __0__1SSSIndex__2__3:packoffset(c48);
};
SamplerState SampStateTrilinearClamp:register(s46, space3);
SamplerState ssFwdBilinearWrap:register(s44, space3);
SamplerState ssMaterialTrilinear:register(s36, space3);
SamplerState ssMaterialTrilinearClamp:register(s38, space3);
SamplerComparisonState ssFwdComparison:register(s45, space3);
SamplerState ssMaterialAnisoHigh:register(s34, space3);
SamplerState ssMaterialAnisoHighBorder:register(s40, space3);
SamplerState vfTrilinearClampSState;
Texture3D<float4>VolumetricFogTexture;
Texture2D emittanceTex:register(t14, space2);
Texture2D<float4>Fwd_ShadowPool:register(t8, space3);
Texture2D<float4>LTCTex_2:register(t33, space3);
Texture2DArray<float4>Fwd_SunShadowMask:register(t22, space3);
Texture2D normalsTex:register(t2, space2);
Texture3D<float4>Fwd_volFogTex:register(t26, space3);
Texture2D<float4>Fwd_GiSpecularRT:register(t31, space3);
Texture2D<float4>Fwd_GiDiffuseRT:register(t30, space3);
TextureCube<float4>vfGlobalEnvProbeTexture1:register(t11, space3);
TextureCube<float4>Fwd_volFogEnvTex1:register(t28, space3);
TextureCube<float4>Fwd_GlobalProbe:register(t29, space3);
Texture2D smoothnessTex:register(t6, space2);
Texture2D<float4>Fwd_EnvironmentBRDF:register(t24, space3);
Texture2D<float4>LTCTex_1:register(t32, space3);
TextureCubeArray<float4>Fwd_SpecCubeArray:register(t5, space3);
TextureCube envCubeTex:register(t4, space2);
Texture2DArray<float4>Fwd_SpotTexArray:register(t7, space3);
Texture2D<float4>Fwd_RandomRotations:register(t9, space3);
TextureCube<float4>Fwd_volFogEnvTex0:register(t27, space3);
Texture2D diffuseTex:register(t1, space2);
TextureCubeArray<float4>Fwd_DiffuseCubeArray:register(t6, space3);
TextureCube<float4>vfGlobalEnvProbeTexture0:register(t10, space3);
struct pixout
{
  half4 Color:SV_Target0;
};
cbuffer CBPerViewGlobal:register(b1, space3)
{
  float4x4 CV_ViewProjZeroMatr;
  float4 CV_AnimGenParams;
  float4x4 CV_ViewProjMatr;
  float4x4 CV_ViewProjNearestMatr;
  float4x4 CV_InvViewProj;
  float4x4 CV_PrevViewProjMatr;
  float4x4 CV_PrevViewProjNearestMatr;
  float3x4 CV_ScreenToWorldBasis;
  float4 CV_TessInfo;
  float4 CV_WorldViewPosition;
  float4 CV_CameraRightVector;
  float4 CV_CameraFrontVector;
  float4 CV_CameraUpVector;
  float4 CV_ScreenSize;
  float4 CV_HPosScale;
  float4 CV_ProjRatio;
  float4 CV_NearestScaled;
  float4 CV_NearFarClipDist;
  float4 CV_SunLightDir;
  float4 CV_SunColor;
  float4 CV_SkyColor;
  float4 CV_FogColor;
  float4 CV_TerrainInfo;
  float4 CV_DecalZFightingRemedy;
  float4x4 CV_FrustumPlaneEquation;
  float4 CV_WindGridOffset;
  float4x4 CV_ViewMatr;
  float4x4 CV_InvViewMatr;
  float4x4 CV_ProjMatr;
  float4x4 CV_ProjMatrUnjittered;
};
cbuffer CBPerPassShadowGen:register(b0, space3)
{
  float4 CP_ShadowGen_LightPos;
  float4 CP_ShadowGen_ViewPos;
  float4 CP_ShadowGen_DepthTestBias;
  float4 CP_ShadowGen_FrustumInfo;
  float4 CP_ShadowGen_VegetationAlphaClamp;
};
cbuffer CBPerPassCustom:register(b0, space3)
{
  float4 CP_Custom_ViewMode;
};
cbuffer CB_SkinQuat_Cur:register(b2)
{
  float2x4 _g_SkinQuat_Cur[768];
};
cbuffer CB_SkinQuat_Prev:register(b3)
{
  float2x4 _g_SkinQuat_Prev[768];
};
uint selectCubeFace(in float3 rayVec)
{
  float3 dir=abs(rayVec);
  bool3 pmag=bool3(dir.x>dir.y,dir.y>dir.z,dir.x>dir.z);
  bool3 nmag=bool3(dir.x<=dir.y,dir.y<=dir.z,dir.x<=dir.z);
  bool3 flp=bool3(rayVec.x==dir.x,rayVec.y==dir.y,rayVec.z==dir.z);
  uint cubeFace=(pmag.x)*(pmag.z)*(0+flp.x)+(nmag.x)*(pmag.y)*(2+flp.y)+(nmag.z)*(nmag.y)*(4+flp.z);
  return cubeFace;
}
half3 GetLuminanceWeights()
{
  return half3(0.2126h,0.7152h,0.0722h);
}
half GetLuminance(half3 color)
{
  return dot(color,GetLuminanceWeights());
}
half4 GetTexture2D(Texture2D tex,SamplerState samplerState,float2 uv)
{
  return tex.Sample(samplerState,uv);
}
half2 GetXYNormalMap(Texture2D bumpTex,float2 bumpTC)
{
  return GetTexture2D(bumpTex,ssMaterialAnisoHigh,bumpTC).yx;
}
half2 GetXYNormalMap(Texture2D bumpTex,SamplerState samplerState,float2 bumpTC)
{
  return GetTexture2D(bumpTex,samplerState,bumpTC).yx;
}
half3 GetNormalMap(Texture2D bumpTex,float2 bumpTC)
{
  half3 bumpNormal;
  bumpNormal.xy=GetXYNormalMap(bumpTex,bumpTC.xy);
  bumpNormal.z=sqrt(saturate(1.h+dot(bumpNormal.xy,-bumpNormal.xy)));
  return bumpNormal;
}
half3 GetNormalMap(Texture2D bumpTex,SamplerState samplerState,float2 bumpTC)
{
  half3 bumpNormal;
  bumpNormal.xy=GetXYNormalMap(bumpTex,samplerState,bumpTC.xy);
  bumpNormal.z=sqrt(saturate(1.h+dot(bumpNormal.xy,-bumpNormal.xy)));
  return bumpNormal;
}
half GetAlphaTex(Texture2D tex,float2 texTC)
{
  return GetTexture2D(tex,ssMaterialAnisoHigh,texTC.xy).a;
}
half4 GetDiffuseTex(Texture2D tex,float2 texTC)
{
  return GetTexture2D(tex,ssMaterialAnisoHigh,texTC.xy);
}
half4 GetDiffuseDecalTex(Texture2D tex,float2 texTC)
{
  return GetTexture2D(tex,ssMaterialAnisoHighBorder,texTC.xy);
}
half GetSmoothnessTex(Texture2D tex,float2 texTC)
{
  return GetTexture2D(tex,ssMaterialTrilinear,texTC.xy).r;
}
half4 GetEmittanceTex(Texture2D tex,float2 texTC)
{
  return GetTexture2D(tex,ssMaterialAnisoHigh,texTC.xy);
}
float3 GetWorldViewPos()
{
  return float3(CV_ScreenToWorldBasis[0][3],CV_ScreenToWorldBasis[1][3],CV_ScreenToWorldBasis[2][3]);
}
struct MaterialAttribsCommon
{
  half3 NormalWorld;
  half3 Albedo;
  half3 Reflectance;
  half3 Transmittance;
  half Smoothness;
  half ScatteringIndex;
  half SelfShadowingSun;
  int LightingModel;
};
MaterialAttribsCommon MaterialAttribsDefault()
{
  MaterialAttribsCommon attribs=(MaterialAttribsCommon)0;
  return attribs;
}
struct CustomForwardShadingAttribs
{};
struct AreaLightShadingAttribs
{
  float4x4 transform;
  float3 position;
  float3 lightPos;
  uint lightArrayIdx;
};
struct ForwardShadingAttribs
{
  float2 screenUV;
  float3 worldPos;
  float3 normal;
  float3 normalSpecProbe;
  float3 reflectance;
  float3 albedo;
  float smoothness;
  CustomForwardShadingAttribs custom;
  AreaLightShadingAttribs areaAttribs;
};
struct STiledLightShadeInfo
{
  uint lightType;
  uint resIndex;
  uint shadowMaskIndex;
  uint stencilID;
  float4 posRad;
  float2 attenuationParams;
  float2 shadowParams;
  float4 color;
  float4x4 projectorMatrix;
  float4x4 shadowMatrix;
};
struct ForwardLightParams
{
  int type;
  float3 lightVec;
  float3 illuminance;
};
half smoothstep_opt(in half maxi,in half x)
{
  x=saturate(x/maxi);
  return x*x*(3.0-2.0*x);
}
half3 GetEnvmapFresnel(half3 specCol0,half gloss,half fNdotE)
{
  const half3 specCol90=half3(1,1,1);
  return lerp(specCol0,specCol90,pow(1-saturate(fNdotE),5)/(40-39*gloss));
}
half GetAttenuation(half3 L,half fInvRadius,bool bUserFalloff=false,half fFalloffMax=1.0h)
{
  half3 vDist=L*fInvRadius;
  half fFallOff=saturate(1+dot(vDist,-vDist));
  if(bUserFalloff)fFallOff=smoothstep_opt(fFalloffMax,fFallOff);
  return fFallOff;
}
half GetPhysicalLightAttenuation(half fDist,half fInvRadius,half fAttenuationBulbSize)
{
  const half radius=1/fInvRadius;
  half d=fDist;
  half fadeoutFactor=saturate((radius-d)*(fInvRadius/0.2h));
  d=max(d-fAttenuationBulbSize,0);
  half denom=1+d/fAttenuationBulbSize;
  half fAttenuation=fadeoutFactor*fadeoutFactor/(denom*denom);
  return fAttenuation;
}
float3 MapCubeToSphere(float3 pos)
{
  float3 pos2=pos.xyz*pos.xyz;
  return pos*sqrt(1-rcp(2)*(pos2.yzx+pos2.zxy)+rcp(3)*(pos2.yzx*pos2.zxy));
}
half SmoothnessToRoughness(half smoothness)
{
  return(1.0f-smoothness)*(1.0f-smoothness);
}
half3 SpecularBRDF(half3 N,half3 V,half3 L,half m,half3 f0,half NormalizationFactor)
{
  half m2=m*m;
  half3 H=normalize(V+L);
  half NdotH=saturate(dot(N,H));
  half spec=(NdotH*m2-NdotH)*NdotH+1;
  spec=m2/(spec*spec)*NormalizationFactor;
  half NdotL=saturate(dot(N,L));
  half NdotV=abs(dot(N,V))+1e-5h;
  half Gv=NdotL*sqrt((-NdotV*m2+NdotV)*NdotV+m2);
  half Gl=NdotV*sqrt((-NdotL*m2+NdotL)*NdotL+m2);
  spec*=0.5h/(Gv+Gl);
  half f90=saturate(dot(f0,0.33333h)/0.02h);
  half3 fresnel=lerp(f0,f90,pow(1-saturate(dot(L,H)),5));
  return fresnel*spec;
}
half3 SpecularBRDF(half3 N,half3 V,half3 L,half Gloss,half3 SpecCol)
{
  half m=max(SmoothnessToRoughness(Gloss),0.001);
  return SpecularBRDF(N,V,L,m,SpecCol,1.0f);
}
static const float LTC_LUT_SIZE=64.0f;
static const float LTC_LUT_SCALE=(LTC_LUT_SIZE-1.0f)/LTC_LUT_SIZE;
static const float LTC_LUT_BIAS=0.5f/LTC_LUT_SIZE;
float3 IntegrateEdgeVec(float3 v1,float3 v2)
{
  float x=dot(v1,v2);
  float y=abs(x);
  float a=0.8543985+(0.4965155+0.0145206*y)*y;
  float b=3.4175940+(4.1616724+y)*y;
  float v=a/b;
  float theta_sintheta=(x>0.0)?v:0.5*rsqrt(max(1.0-x*x,1e-7))-v;
  return cross(v1,v2)*theta_sintheta;
}
float3 SolveCubic(float4 Coefficient)
{
  Coefficient.xyz/=Coefficient.w;
  Coefficient.yz/=3.0f;
  float A=Coefficient.w;
  float B=Coefficient.z;
  float C=Coefficient.y;
  float D=Coefficient.x;
  float3 Delta=float3(-Coefficient.z*Coefficient.z+Coefficient.y,-Coefficient.y*Coefficient.z+Coefficient.x,dot(float2(Coefficient.z,-Coefficient.y),Coefficient.xy));
  float Discriminant=dot(float2(4.0f*Delta.x,-Delta.y),Delta.zy);
  float3 RootsA,RootsD;
  float2 xlc,xsc;
  
  {
    float A_a=1.0f;
    float C_a=Delta.x;
    float D_a=-2.0f*B*Delta.x+Delta.y;
    float Theta=atan2(sqrt(Discriminant),-D_a)/3.0f;
    float x_1a=2.0f*sqrt(-C_a)*cos(Theta);
    float x_3a=2.0f*sqrt(-C_a)*cos(Theta+(2.0f/3.0f)*3.1415);
    float xl;
    if((x_1a+x_3a)>2.0f*B)xl=x_1a;
    else xl=x_3a;
    xlc=float2(xl-B,A);
  }
  
  {
    float A_d=D;
    float C_d=Delta.z;
    float D_d=-D*Delta.y+2.0f*C*Delta.z;
    float Theta=atan2(D*sqrt(Discriminant),-D_d)/3.0f;
    float x_1d=2.0f*sqrt(-C_d)*cos(Theta);
    float x_3d=2.0f*sqrt(-C_d)*cos(Theta+(2.0f/3.0f)*3.1415);
    float xs;
    if(x_1d+x_3d<2.0f*C)xs=x_1d;
    else xs=x_3d;
    xsc=float2(-D,xs+C);
  }
  float E=xlc.y*xsc.y;
  float F=-xlc.x*xsc.y-xlc.y*xsc.x;
  float G=xlc.x*xsc.x;
  float2 xmc=float2(C*F-B*G,-B*F+C*E);
  float3 Root=float3(xsc.x/xsc.y,xmc.x/xmc.y,xlc.x/xlc.y);
  if(Root.x<Root.y&&Root.x<Root.z)Root.xyz=Root.yxz;
  else if(Root.z<Root.x&&Root.z<Root.y)Root.xyz=Root.xzy;
  return Root;
}
float3 FetchDiffuseFilteredTexture(Texture2DArray<float4>texArray,float lightArrayIdx,float3 p1_,float3 p2_,float3 p3_,float3 p4_,bool useMips)
{
  float3 V1=p2_-p1_;
  float3 V2=p4_-p1_;
  float3 planeOrtho=(cross(V1,V2));
  float planeAreaSquared=dot(planeOrtho,planeOrtho);
  float planeDistxPlaneArea=dot(planeOrtho,p1_);
  float3 P=planeDistxPlaneArea*planeOrtho/planeAreaSquared-p1_;
  float dot_V1_V2=dot(V1,V2);
  float inv_dot_V1_V1=1.0f/dot(V1,V1);
  float3 V2_=V2-V1*dot_V1_V2*inv_dot_V1_V1;
  float2 Puv;
  Puv.y=dot(V2_,P)/dot(V2_,V2_);
  Puv.x=dot(V1,P)*inv_dot_V1_V1-dot_V1_V2*inv_dot_V1_V1*Puv.y;
  float d=0;
  if(useMips)
  {
    d=abs(planeDistxPlaneArea)/pow(planeAreaSquared,0.75f);
  }
  return texArray.SampleLevel(SampStateTrilinearClamp,float3(float2(0.125f,0.125f)+0.75f*Puv,lightArrayIdx),log(2048.0f*d)/log(3.0f)).r;
}
float2 LTC_Evaluate(float3 N,float3 V,float Gloss,inout float3x3 matILT,inout float3x3 matIdentity,inout float3 T1,inout float3 T2)
{
  float m=max(SmoothnessToRoughness(Gloss),0.02f);
  float NdotV=saturate(dot(N,V));
  float2 texUV=float2(m,sqrt(1.0f-NdotV));
  texUV=texUV*LTC_LUT_SCALE+LTC_LUT_BIAS;
  float4 t1=LTCTex_1.SampleLevel(SampStateTrilinearClamp,texUV,0);
  float4 t2=LTCTex_2.SampleLevel(SampStateTrilinearClamp,texUV,0);
  matILT=float3x3(t1.x,0,t1.z,0,1,0,t1.y,0,t1.w);
  matIdentity=float3x3(1,0,0,0,1,0,0,0,1);
  T1=normalize(V-N*NdotV);
  T2=cross(N,T1);
  return float2(t2.x,t2.y);
}
float3 LTC_Rectangle(float3 N,float3 P,float3x3 mat,float3 points[4],float3 T1,float3 T2,float lightArrayIdx,bool twoSided,bool behind,bool textured,Texture2DArray<float4>texArray)
{
  mat=mul(mat,float3x3(T1,T2,N));
  float3 L[4];
  L[0]=mul(mat,points[0]-P);
  L[1]=mul(mat,points[1]-P);
  L[2]=mul(mat,points[2]-P);
  L[3]=mul(mat,points[3]-P);
  float3 texturedLight=1.0f;
  if(textured)
  {
    texturedLight=FetchDiffuseFilteredTexture(texArray,lightArrayIdx,L[0],L[1],L[2],L[3],true);
  }
  float sum=0.0f;
  L[0]=normalize(L[0]);
  L[1]=normalize(L[1]);
  L[2]=normalize(L[2]);
  L[3]=normalize(L[3]);
  float3 vsum=0.0f;
  vsum+=IntegrateEdgeVec(L[0],L[1]);
  vsum+=IntegrateEdgeVec(L[1],L[2]);
  vsum+=IntegrateEdgeVec(L[2],L[3]);
  vsum+=IntegrateEdgeVec(L[3],L[0]);
  float len=length(vsum);
  float z=(behind?-vsum.z:vsum.z)/len;
  float2 uv=float2(z*0.5f+0.5f,len);
  uv=uv*LTC_LUT_SCALE+LTC_LUT_BIAS;
  float scale=LTCTex_2.SampleLevel(SampStateTrilinearClamp,uv,0).w;
  sum=len*scale;
  float3 output=float3(sum,sum,sum);
  output*=texturedLight;
  return output;
}
float3 LTC_Disk(float3 N,float3 P,float3x3 mat,float3 points[4],float3 T1,float3 T2,bool twoSided,bool behind)
{
  float3x3 R=float3x3(T1,T2,N);
  float3 L_[3];
  L_[0]=mul(R,points[0]-P);
  L_[1]=mul(R,points[1]-P);
  L_[2]=mul(R,points[2]-P);
  float3 sum=0;
  float3 C=0.5f*(L_[0]+L_[2]);
  float3 V1=0.5f*(L_[1]-L_[2]);
  float3 V2=0.5f*(L_[1]-L_[0]);
  C=mul(mat,C);
  V1=mul(mat,V1);
  V2=mul(mat,V2);
  float earlyOut=dot(cross(V1,V2),C);
  if(!twoSided&&earlyOut<1e-6)return 0.0f;
  else if(twoSided&&earlyOut<1e-6&&earlyOut>-1e-6)return 0.0f;
  float a=0;
  float b=0;
  float d11=dot(V1,V1);
  float d22=dot(V2,V2);
  float d12=dot(V1,V2);
  if(abs(d12)/sqrt(d11*d22)>0.001f)
  {
    float tr=d11+d22;
    float det=-d12*d12+d11*d22;
    det=sqrt(det);
    float u=0.5f*sqrt(tr-2.0f*det);
    float v=0.5f*sqrt(tr+2.0f*det);
    float e_max=(u+v);
    float e_min=(u-v);
    float e_max2=e_max*e_max;
    float e_min2=e_min*e_min;
    float3 V1_,V2_;
    if(d11>d22)
    {
      V1_=d12*V1+(e_max2-d11)*V2;
      V2_=d12*V1+(e_min2-d11)*V2;
    }
    else
    {
      V1_=d12*V2+(e_max2-d22)*V1;
      V2_=d12*V2+(e_min2-d22)*V1;
    }
    a=1.0f/e_max2;
    b=1.0f/e_min2;
    V1=normalize(V1_);
    V2=normalize(V2_);
  }
  else
  {
    a=1.0f/dot(V1,V1);
    b=1.0f/dot(V2,V2);
    V1*=sqrt(a);
    V2*=sqrt(b);
  }
  float3 V3=cross(V1,V2);
  if(dot(C,V3)<0.0f)V3*=-1.0f;
  float L=dot(V3,C);
  float x0=dot(V1,C)/L;
  float y0=dot(V2,C)/L;
  a*=(L*L);
  b*=(L*L);
  float c0=a*b;
  float c1=a*b*(1.0f+x0*x0+y0*y0)-a-b;
  float c2=1.0f-a*(1.0f+x0*x0)-b*(1.0f+y0*y0);
  float c3=1.0f;
  float3 roots=SolveCubic(float4(c0,c1,c2,c3));
  float e1=roots.x;
  float e2=roots.y;
  float e3=roots.z;
  float3 avgDir=float3(a*x0/(a-e2),b*y0/(b-e2),1.0f);
  float3x3 rotate=transpose(float3x3(V1,V2,V3));
  avgDir=mul(rotate,avgDir);
  avgDir=normalize(avgDir);
  float L1=sqrt(-e2/e3);
  float L2=sqrt(-e2/e1);
  float formFactor=L1*L2*rsqrt((1.0f+L1*L1)*(1.0f+L2*L2));
  float2 uv=float2(avgDir.z*0.5f+0.5f,formFactor);
  uv=uv*LTC_LUT_SCALE+LTC_LUT_BIAS;
  float scale=LTCTex_2.SampleLevel(SampStateTrilinearClamp,uv,0).w;
  sum=formFactor*scale;
  float3 output=sum;
  return output;
}
void AreaLightLTC_GGX(float3 N,float3 V,float Gloss,float3 SpecCol,float3 position,float3 lightPos,float lightArrayIdx,float4x4 lightParamMatrix,Texture2DArray<float4>texArray,inout float3 outDiffuse,inout float3 outSpecular)
{
  float3 points[4];
  points[0]=float3(lightParamMatrix[0][0],lightParamMatrix[0][1],lightParamMatrix[0][2]);
  points[1]=float3(lightParamMatrix[1][0],lightParamMatrix[1][1],lightParamMatrix[1][2]);
  points[2]=float3(lightParamMatrix[2][0],lightParamMatrix[2][1],lightParamMatrix[2][2]);
  points[3]=float3(lightParamMatrix[3][0],lightParamMatrix[3][1],lightParamMatrix[3][2]);
  uint shape=lightParamMatrix[0][3];
  bool twoSided=lightParamMatrix[1][3];
  bool textured=lightParamMatrix[2][3];
  float3 center=float3((points[0].x+points[1].x)/2,points[0].y,(points[0].z+points[2].z)/2)-position;
  float3 lightNormal=cross(points[1]-points[0],points[3]-points[0]);
  bool behindLight=dot(points[0]-position,lightNormal)<0.0f;
  if((behindLight&&!twoSided))
  {
    outDiffuse=0;
    outSpecular=0;
    return;
  }
  float3x3 matILT,matIdentity;
  float3 T1,T2;
  float2 F_G=LTC_Evaluate(N,V,Gloss,matILT,matIdentity,T1,T2);
  if(shape==1)
  {
    outDiffuse=LTC_Rectangle(N,position,matIdentity,points,T1,T2,lightArrayIdx,twoSided,behindLight,textured,texArray);
    outSpecular=LTC_Rectangle(N,position,matILT,points,T1,T2,lightArrayIdx,twoSided,behindLight,textured,texArray);
  }
  else if(shape==2)
  {
    outDiffuse=LTC_Disk(N,position,matIdentity,points,T1,T2,twoSided,behindLight);
    outSpecular=LTC_Disk(N,position,matILT,points,T1,T2,twoSided,behindLight);
  }
  float cosTheta_i=saturate(dot(center,N));
  outSpecular*=cosTheta_i*SpecCol*F_G.x+(1.0-SpecCol)*F_G.y;
}
half Pow5(half v)
{
  return v*v*v*v*v;
}
half BurleyBRDF(half3 NdotL,half3 NdotV,half3 VdotH,half roughness)
{
  NdotV=max(NdotV,0.1);
  half energyBias=0.5*roughness;
  half energyFactor=lerp(1,1/1.51,roughness);
  half fd90=energyBias+2.0*VdotH*VdotH*roughness;
  half scatterL=lerp(1,fd90,Pow5(1-NdotL));
  half scatterV=lerp(1,fd90,Pow5(1-NdotV));
  return scatterL*scatterV*energyFactor*NdotL;
}
half DiffuseBRDF(half3 N,half3 V,half3 L,half Gloss,half NdotL)
{
  half m=SmoothnessToRoughness(min(Gloss,1));
  half VdotH=saturate(dot(V,normalize(V+L)));
  half NdotV=abs(dot(N,V))+1e-5h;
  return BurleyBRDF(NdotL,NdotV,VdotH,m);
}
half DeriveSpecularOcclusion(half fNdotV,half aoAmount,half smoothness)
{
  return saturate(pow(fNdotV+aoAmount,smoothness)-1+aoAmount);
}
half4 DecodeHDRCubemap(half4 color)
{
  return color;
}
half4 GetEnvironmentCMap(TextureCube envCubeTex,SamplerState envCubeSampler,in half3 envTC,in half fGloss)
{
  const half numCMapMips=6.0;
  half fGlossinessLod=numCMapMips-fGloss*numCMapMips;
  half4 envColor=DecodeHDRCubemap(envCubeTex.SampleLevel(envCubeSampler,envTC,fGlossinessLod));
  return envColor;
}
void CubemapBoxParallaxCorrection(inout half3 vReflVec,in half3 vPosLightDist,in half3 vBoxExtentsMin,in half3 vBoxExtentsMax,inout half fGloss)
{
  half3 vReflVecN=normalize(vReflVec.xyz);
  half3 vBoxIntersectionMax=(vPosLightDist+vBoxExtentsMax)/vReflVecN;
  half3 vBoxIntersectionMin=(vPosLightDist+vBoxExtentsMin)/vReflVecN;
  half3 vFurthestPlane=select(vReflVecN>0.F,vBoxIntersectionMax,vBoxIntersectionMin);
  half fDistance=min(min(vFurthestPlane.x,vFurthestPlane.y),vFurthestPlane.z);
  half3 vInterectionPos=-vPosLightDist;
  vReflVec=vInterectionPos+(vReflVecN*fDistance);
}
struct SFogParams
{
  float3 viewPos;
  float padding0;
  float heightDensityScale;
  float heightDensityAtBaseHeight;
  float heightDiffFromBase;
  float expHeightDiffFromBase;
  float4 rampParams;
  float3 sunDir;
  float densityClamp;
  float3 colGradBase;
  float padding1;
  float3 colGradDelta;
  float padding2;
  float heightColGradScale;
  float heightColGradOffset;
  float radialSizeCtrl;
  float radialLobeCtrl;
  float3 radialColor;
  float invZFar;
};
SFogParams GetFogParamsInternal()
{
  SFogParams params;
  params.viewPos.xyz=GetWorldViewPos();
  params.padding0=0.0f;
  params.heightDensityScale=vfParams.x;
  params.heightDensityAtBaseHeight=vfParams.y;
  params.heightDiffFromBase=vfParams.z;
  params.expHeightDiffFromBase=vfParams.w;
  params.rampParams=vfRampParams;
  params.sunDir=vfSunDir.xyz;
  params.densityClamp=vfSunDir.w;
  params.colGradBase=vfColGradBase;
  params.padding1=0.0f;
  params.colGradDelta=vfColGradDelta;
  params.padding2=0.0f;
  params.heightColGradScale=vfColGradParams.x;
  params.heightColGradOffset=vfColGradParams.y;
  params.radialSizeCtrl=vfColGradParams.z;
  params.radialLobeCtrl=vfColGradParams.w;
  params.radialColor=vfColGradRadial.xyz;
  params.invZFar=vfColGradRadial.w;
  return params;
}
float ComputeVolumetricFogInternal(in float3 cameraToWorldPos,in SFogParams fogParams)
{
  float fogInt=1.0;
  const float t=fogParams.heightDensityScale*cameraToWorldPos.z;
  if(abs(t)>0.01)
  {
    fogInt*=(exp(t+fogParams.heightDiffFromBase)-fogParams.expHeightDiffFromBase)/t;
  }
  else
  {
    fogInt*=fogParams.expHeightDiffFromBase;
  }
  const float l=length(cameraToWorldPos);
  const float u=l*fogParams.heightDensityAtBaseHeight;
  fogInt*=u;
  float f=saturate(exp2(-fogInt));
  half r=saturate(l*fogParams.rampParams.x+fogParams.rampParams.y);
  r=r*(2-r);
  r=r*fogParams.rampParams.z+fogParams.rampParams.w;
  f=(1-f)*r;
  return max(1-f,fogParams.densityClamp);
}
float4 GetVolumetricFogColorInternal(in float3 worldPos,in float3 cameraToWorldPos,in float radialFogShadowInfluence,in float ambientFogShadowInfluence,in SFogParams fogParams)
{
  const float fog=ComputeVolumetricFogInternal(cameraToWorldPos,fogParams);
  half h=saturate(worldPos.z*fogParams.heightColGradScale+fogParams.heightColGradOffset);
  h=h*(2-h);
  half3 fogColor=(fogParams.colGradBase+h*fogParams.colGradDelta)*ambientFogShadowInfluence;
  const half l=saturate(length(cameraToWorldPos)*fogParams.invZFar);
  const half radialLobe=pow(l,fogParams.radialLobeCtrl);
  const half radialSize=exp2(dot(normalize(cameraToWorldPos),fogParams.sunDir.xyz)*-fogParams.radialSizeCtrl+fogParams.radialSizeCtrl);
  fogColor+=radialLobe*radialSize*fogParams.radialColor*radialFogShadowInfluence;
  return float4(fogColor,fog);
}
float4 GetVolumetricFogColorInternal(in float3 worldPos,in SFogParams fogParams)
{
  const float3 camToWorld=worldPos-fogParams.viewPos.xyz;
  return GetVolumetricFogColorInternal(worldPos,camToWorld,1,1,fogParams);
}
float4 GetVolumetricFogColor(in float3 worldPos,in float3 cameraToWorldPos,in float radialFogShadowInfluence,in float ambientFogShadowInfluence)
{
  const SFogParams fogParams=GetFogParamsInternal();
  return GetVolumetricFogColorInternal(worldPos,cameraToWorldPos,radialFogShadowInfluence,ambientFogShadowInfluence,fogParams);
}
float4 GetVolumetricFogColor(in SFogParams fogParams,in float3 worldPos,in float3 cameraToWorldPos,in float radialFogShadowInfluence,in float ambientFogShadowInfluence)
{
  return GetVolumetricFogColorInternal(worldPos,cameraToWorldPos,radialFogShadowInfluence,ambientFogShadowInfluence,fogParams);
}
float4 GetVolumetricFogColor(in float3 worldPos,in float3 cameraToWorldPos)
{
  const SFogParams fogParams=GetFogParamsInternal();
  return GetVolumetricFogColorInternal(worldPos,cameraToWorldPos,1,1,fogParams);
}
float4 GetVolumetricFogColor(in SFogParams fogParams,in float3 worldPos,in float3 cameraToWorldPos)
{
  return GetVolumetricFogColorInternal(worldPos,cameraToWorldPos,1,1,fogParams);
}
float4 GetVolumetricFogColor(in float3 worldPos)
{
  const SFogParams fogParams=GetFogParamsInternal();
  return GetVolumetricFogColorInternal(worldPos,fogParams);
}
float4 GetVolumetricFogColor(in SFogParams fogParams,in float3 worldPos)
{
  return GetVolumetricFogColorInternal(worldPos,fogParams);
}
struct VolumetricFogLight
{
  float3 cDiffuse;
  float fFallOff;
  float radialLobe;
  float dotLE;
  float k;
  float k2;
};
struct VolumetricFogSunLight
{
  float fFallOff;
  float dotLE;
  float blendFactor;
  float blendMode;
  float3 cDiffuse1;
  float3 cDiffuse2;
  float2 anisotropy1;
  float2 anisotropy2;
};
struct VolumetricFogTexcoord
{
  float3 texcoord;
  float range;
  float linearDepth;
};
struct VolumetricFogSampling
{Texture3D<float4>volumetricFogTex;
  TextureCube<float4>globalEnvProbeTex0;
  TextureCube<float4>globalEnvProbeTex1;
  SamplerState trilinearClampSState;
};
struct SVolumetricFogParams
{
  float3 sunDir;
  float padding0;
  float nearDist;
  float invFarMinusNearDist;
  float maxIndex;
  float invMaxIndex;
  float2 screenSize;
  float farMinusNearDist;
  float invMaxIndexMinusOne;
  float3 viewPos;
  float framwCountJitter;
  float scatterCoefficient;
  float extinctionCoefficient;
  float blendFactor;
  float blendMode;
  float3 cDiffuse1;
  float padding1;
  float3 cDiffuse2;
  float padding2;
  float2 anisotropy1;
  float2 anisotropy2;
  float heightDensityScale;
  float densityAtViewer;
  float fogVisibility;
  float clampTransmittance;
  float rampStart;
  float rampEnd;
  float oneOverRampDiff;
  float rampStartOverRampDiff;
  float farDistTopLeft;
  float farDistTopCenter;
  float farDistCenterLeft;
  float farDistCenter;
  float4 timeParams;
};
SVolumetricFogParams vfGetVolumetricFogParamsInternal()
{
  SVolumetricFogParams params;
  params.sunDir=vfSunDir.xyz;
  params.padding0=0.0f;
  params.nearDist=vfSamplingParams.x;
  params.invFarMinusNearDist=vfSamplingParams.y;
  params.maxIndex=vfSamplingParams.z;
  params.invMaxIndex=vfSamplingParams.w;
  params.screenSize=CV_ScreenSize.xy;
  params.farMinusNearDist=vfDistributionParams.y;
  params.invMaxIndexMinusOne=vfDistributionParams.z;
  params.viewPos=GetWorldViewPos();
  params.framwCountJitter=vfDistributionParams.w;
  params.scatterCoefficient=vfScatteringParams.x;
  params.extinctionCoefficient=vfScatteringParams.y;
  params.blendFactor=vfScatteringBlendParams.x;
  params.blendMode=vfScatteringBlendParams.y;
  params.cDiffuse1=vfScatteringColor.xyz;
  params.padding1=0.0f;
  params.cDiffuse2=vfScatteringSecondaryColor.xyz;
  params.padding2=0.0f;
  params.anisotropy1.x=vfScatteringParams.z;
  params.anisotropy1.y=vfScatteringParams.w;
  params.anisotropy2.x=vfScatteringColor.w;
  params.anisotropy2.y=vfScatteringSecondaryColor.w;
  params.heightDensityScale=vfHeightDensityParams.x;
  params.densityAtViewer=vfHeightDensityParams.y;
  params.fogVisibility=vfHeightDensityParams.z;
  params.clampTransmittance=vfHeightDensityParams.w;
  params.rampStart=vfHeightDensityRampParams.x;
  params.rampEnd=vfHeightDensityRampParams.y;
  params.oneOverRampDiff=vfHeightDensityRampParams.z;
  params.rampStartOverRampDiff=vfHeightDensityRampParams.w;
  params.farDistTopLeft=vfDistanceParams.x;
  params.farDistTopCenter=vfDistanceParams.y;
  params.farDistCenterLeft=vfDistanceParams.z;
  params.farDistCenter=vfDistanceParams.w;
  params.timeParams=vfTimeParams;
  return params;
}
float GetVolumetricFogInscatteringSchlickPhaseFunction(float dotLE,float k,float oneMinusK2)
{
  const float k2=oneMinusK2;
  float h=-((k*dotLE)-1.0f);
  return(k2/(4.0f*3.1415*h*h));
}
float GetVolumetricFogInscatteringSideRadialPhaseFunction(float dotLE)
{
  float factor=(1.0f-abs(dotLE));
  return(factor*(1.0f/(3.1415*3.1415)));
}
float3 GetVolumetricFogInscattering(in VolumetricFogLight light,bool isotoropic)
{
  float phaseFunc;
  if(isotoropic)
  {
    phaseFunc=1.0f/(4.0f*3.1415);
  }
  else
  {
    const float dotLE=light.dotLE;
    float mainRadialLobe=GetVolumetricFogInscatteringSchlickPhaseFunction(dotLE,light.k,light.k2);
    float sideRadialLobe=GetVolumetricFogInscatteringSideRadialPhaseFunction(dotLE);
    phaseFunc=lerp(mainRadialLobe,sideRadialLobe,light.radialLobe);
  }
  const float attenuation=phaseFunc*light.fFallOff;
  return attenuation*light.cDiffuse;
}
float3 GetVolumetricFogInscatteringSun(in VolumetricFogSunLight light)
{
  const float primaryPhaseFunc=GetVolumetricFogInscatteringSchlickPhaseFunction(light.dotLE,light.anisotropy1.x,light.anisotropy1.y);
  const float secondaryPhaseFunct=GetVolumetricFogInscatteringSchlickPhaseFunction(light.dotLE,light.anisotropy2.x,light.anisotropy2.y);
  const float primaryRadiation=primaryPhaseFunc*light.fFallOff;
  const float secondaryRadiation=secondaryPhaseFunct*light.fFallOff;
  const float3 ins0=primaryRadiation*light.cDiffuse1;
  const float3 ins1=secondaryRadiation*light.cDiffuse2;
  return(ins0*(1.0f-(light.blendFactor*light.blendMode)))+(ins1*light.blendFactor);
}
float4 GetVolumetricFogAnalyticalColor(in SVolumetricFogParams params,in VolumetricFogSampling vfs,in float3 cameraToWorldPos,in float lengthToTarget,in bool fullSpan=false)
{
  float3 inscatter=float3(0.0f,0.0f,0.0f);
  float4 diffuseProbe0=float4(0.0f,0.0f,0.0f,0.0f);
  float4 diffuseProbe1=float4(0.0f,0.0f,0.0f,0.0f);
  const float d=lengthToTarget;
  const float L=params.heightDensityScale;
  const float M=cameraToWorldPos.z/d;
  const float volFogDensityAtViewer=params.densityAtViewer;
  const float extinctionCoefficient=params.extinctionCoefficient;
  const float rampStart=params.rampStart;
  const float rampEnd=params.rampEnd;
  const float transitionDistance=fullSpan?0.1f:params.farDistCenter;
  VolumetricFogSunLight vfLight;
  vfLight.dotLE=dot(params.sunDir.xyz,normalize(cameraToWorldPos));
  vfLight.fFallOff=1.0f;
  vfLight.blendFactor=params.blendFactor;
  vfLight.blendMode=params.blendMode;
  vfLight.cDiffuse1=params.cDiffuse1.xyz;
  vfLight.cDiffuse2=params.cDiffuse2.xyz;
  vfLight.anisotropy1.x=params.anisotropy1.x;
  vfLight.anisotropy1.y=params.anisotropy1.y;
  vfLight.anisotropy2.x=params.anisotropy2.x;
  vfLight.anisotropy2.y=params.anisotropy2.y;
  inscatter+=GetVolumetricFogInscatteringSun(vfLight);
  float invExtinction=rcp(extinctionCoefficient);
  inscatter*=params.scatterCoefficient*invExtinction;
  float LM=L*M;
  LM=abs(LM)<0.000001f?0.000001f:LM;
  float invLM=rcp(LM);
  float cLM=-extinctionCoefficient*volFogDensityAtViewer*invLM;
  float d2=min(transitionDistance,d);
  float minD=min(d,transitionDistance<rampStart?rampStart:transitionDistance);
  float maxD=min(d,rampEnd);
  float sd=max(rampEnd,d2);
  float logeLM=1.442695f*LM;
  float expLMd=exp2(logeLM*d);
  float4 fogColor;
  float T0=saturate(exp2(cLM*(expLMd-exp2(logeLM*sd))));
  fogColor.a=T0;
  VolumetricFogLight fragLight;
  fragLight.fFallOff=1.0f;
  fragLight.radialLobe=0.0f;
  fragLight.dotLE=1.0f;
  fragLight.k=0.0f;
  fragLight.k2=1.0f;
  fragLight.cDiffuse=diffuseProbe0.rgb+diffuseProbe1.rgb;
  inscatter+=GetVolumetricFogInscattering(fragLight,true);
  float trns=1.0f;
  fogColor.xyz=0.0f;
  if(rampEnd-rampStart>1.0f&&transitionDistance<rampEnd)
  {
    LM=abs(LM)<0.0001f?0.0001f:LM;
    logeLM=1.442695f*LM;
    float CC=rcp(LM*LM*(rampStart-rampEnd));
    float cCC=-extinctionCoefficient*volFogDensityAtViewer*CC;
    float A0=exp2(logeLM*maxD)*(LM*(rampStart-maxD)+1.0f);
    float A1=exp2(logeLM*minD)*(LM*(rampStart-minD)+1.0f);
    trns=saturate(exp2(cCC*(A0-A1)));
    fogColor.a*=trns;
    float V=exp2(logeLM*rampStart);
    float IE=-exp2(cCC*(A0-V));
    float IS=-exp2(cCC*(A1-V));
    fogColor.xyz+=inscatter*saturate(IE-IS);
  }
  float IE=-T0;
  float IS=-1;
  fogColor.xyz+=trns*inscatter*(IE-IS);
  return fogColor;
}
float4 GetVolumetricFogAnalyticalColor(in VolumetricFogSampling vfs,in float3 cameraToWorldPos,in float lengthToTarget,in bool fullSpan=false)
{
  SVolumetricFogParams params=vfGetVolumetricFogParamsInternal();
  return GetVolumetricFogAnalyticalColor(params,vfs,cameraToWorldPos,lengthToTarget,fullSpan);
}
float4 GetVolumetricFogAnalyticalColor(in float3 cameraToWorldPos,in float lengthToTarget,in bool fullSpan=false)
{
  SVolumetricFogParams params=vfGetVolumetricFogParamsInternal();
  VolumetricFogSampling vfs;
  vfs.volumetricFogTex=VolumetricFogTexture;
  vfs.globalEnvProbeTex0=vfGlobalEnvProbeTexture0;
  vfs.globalEnvProbeTex1=vfGlobalEnvProbeTexture1;
  vfs.trilinearClampSState=vfTrilinearClampSState;
  return GetVolumetricFogAnalyticalColor(params,vfs,cameraToWorldPos,lengthToTarget,fullSpan);
}
float4 GetVolumetricFogAnalyticalColor(in float3 cameraToWorldPos,in bool fullSpan=false)
{
  SVolumetricFogParams params=vfGetVolumetricFogParamsInternal();
  VolumetricFogSampling vfs;
  vfs.volumetricFogTex=VolumetricFogTexture;
  vfs.globalEnvProbeTex0=vfGlobalEnvProbeTexture0;
  vfs.globalEnvProbeTex1=vfGlobalEnvProbeTexture1;
  vfs.trilinearClampSState=vfTrilinearClampSState;
  return GetVolumetricFogAnalyticalColor(params,vfs,cameraToWorldPos,length(cameraToWorldPos),fullSpan);
}
float4 BlendVolumetricFogWithGlobalFog(in SVolumetricFogParams params,in float4 volumetricFog,in float4 globalFog,in VolumetricFogTexcoord vtc)
{
  volumetricFog.xyz=params.fogVisibility*volumetricFog.w*globalFog.xyz+volumetricFog.xyz;
  volumetricFog.a=volumetricFog.w*globalFog.a;
  return volumetricFog;
}
float4 BlendVolumetricFogWithGlobalFog(in float4 volumetricFog,in float4 globalFog,in VolumetricFogTexcoord vtc)
{
  SVolumetricFogParams params=vfGetVolumetricFogParamsInternal();
  return BlendVolumetricFogWithGlobalFog(params,volumetricFog,globalFog,vtc);
}
float4 ClampFinalFogDensity(in SVolumetricFogParams params,in float4 volumetricFog)
{
  volumetricFog.xyz=volumetricFog.xyz*(1.0f-params.clampTransmittance);
  volumetricFog.a=max(volumetricFog.a,params.clampTransmittance);
  return volumetricFog;
}
float4 ClampFinalFogDensity(in float4 volumetricFog)
{
  SVolumetricFogParams params=vfGetVolumetricFogParamsInternal();
  return ClampFinalFogDensity(params,volumetricFog);
}
float GetVolumetricFogDepthTexcoord(in SVolumetricFogParams params,in float linearDepth)
{
  const float c=(2.0f);
  float d=pow(((linearDepth-params.nearDist)*params.invFarMinusNearDist),(1.0f/c));
  d=(0.5f-d)*params.invMaxIndex+d;
  return d;
}
float GetVolumetricFogDepthTexcoord(in float linearDepth)
{
  SVolumetricFogParams params=vfGetVolumetricFogParamsInternal();
  return GetVolumetricFogDepthTexcoord(params,linearDepth);
}
void RectifyVolumetricFogTexcoordAndRangeApproxInternal(in SVolumetricFogParams params,inout VolumetricFogTexcoord vtc)
{
  float2 atc=abs(vtc.texcoord.xy*2.0f-1.0f);
  vtc.range=lerp(lerp(vtc.range,params.farDistCenterLeft,atc.x),lerp(params.farDistTopCenter,params.farDistTopLeft,atc.x),atc.y);
  vtc.texcoord.z=min(vtc.range,vtc.texcoord.z);
}
void RectifyVolumetricFogTexcoordAndRangeInternal(inout VolumetricFogTexcoord vtc,in float lengthToTarget)
{
  float correctionFactor=(vtc.linearDepth/lengthToTarget);
  vtc.range*=correctionFactor;
  vtc.texcoord.z=min(vtc.range,vtc.texcoord.z);
}
VolumetricFogTexcoord GetVolumetricFogTexcoordParamByScreenPos(in SVolumetricFogParams params,in float4 screenPos,in bool rectifiedRangeApprox=true,in float lengthToTarget=10000000.0f)
{
  VolumetricFogTexcoord vtc;
  vtc.texcoord.xy=screenPos.xy*CV_ScreenSize.zw*2.0f;
  vtc.linearDepth=screenPos.w;
  vtc.texcoord.z=vtc.linearDepth;
  vtc.range=params.farDistCenter;
  if(rectifiedRangeApprox)
  {
    RectifyVolumetricFogTexcoordAndRangeApproxInternal(params,vtc);
  }
  else
  {
    RectifyVolumetricFogTexcoordAndRangeInternal(vtc,lengthToTarget);
  }
  vtc.texcoord.z=GetVolumetricFogDepthTexcoord(params,vtc.texcoord.z);
  return vtc;
}
VolumetricFogTexcoord GetVolumetricFogTexcoordParamByScreenPos(in float4 screenPos,in bool rectifiedRangeApprox=true,in float lengthToTarget=10000000.0f)
{
  SVolumetricFogParams params=vfGetVolumetricFogParamsInternal();
  return GetVolumetricFogTexcoordParamByScreenPos(params,screenPos,rectifiedRangeApprox,lengthToTarget);
}
float4 GetVolumetricFogValue(in VolumetricFogSampling vfs,in VolumetricFogTexcoord vtc)
{
  float3 tc=vtc.texcoord.xyz;
  float4 v=vfs.volumetricFogTex.SampleLevel(vfs.trilinearClampSState,tc.xyz,0.0f);
  return v;
}
float4 GetVolumetricFogValue(in VolumetricFogTexcoord vtc)
{
  VolumetricFogSampling vfs;
  vfs.volumetricFogTex=VolumetricFogTexture;
  vfs.trilinearClampSState=vfTrilinearClampSState;
  return GetVolumetricFogValue(vfs,vtc);
}
void ApplyVolumetricFog(in SVolumetricFogParams params,in float4 volumetricFog,in float4 globalFog,in VolumetricFogTexcoord vtc,inout float3 color)
{
  volumetricFog=BlendVolumetricFogWithGlobalFog(params,volumetricFog,globalFog,vtc);
  volumetricFog=ClampFinalFogDensity(params,volumetricFog);
  color.xyz=(color.xyz*volumetricFog.w)+volumetricFog.xyz;
}
void ApplyVolumetricFog(in float4 volumetricFog,in float4 globalFog,in VolumetricFogTexcoord vtc,inout float3 color)
{
  SVolumetricFogParams params=vfGetVolumetricFogParamsInternal();
  ApplyVolumetricFog(params,volumetricFog,globalFog,vtc,color);
}
cbuffer CBPerInstance:register(b0, space0)
{};
cbuffer CBPerDraw:register(b0, space0)
{
  float3x4 CD_WorldMatrix;
  float3x4 CD_PrevWorldMatrix;
  float4 CD_CustomData;
  float4 CD_CustomData1;
  float4 CD_CustomData2;
  float4 CD_LightMapScaleAndOffset;
};
float Get_MaterialAlphaTest()
{
  return CM_DetailTilingAndAlphaRef.z;
}
struct vert2FragGeneral
{
  float4 WPos:SV_POSITION;
  float4 baseTC:TEXCOORD0;
  float4 vTangent:TEXCOORD1;
  float4 vBinormal:TEXCOORD2;
  float4 vView:TEXCOORD3;
  float4 screenProj:TEXCOORD4;
};
void GatherMaterialAttribs(in half3x3 mTangentToWS,in float2 baseTC,in half4 vertexColor,out MaterialAttribsCommon attribs)
{
  attribs=MaterialAttribsDefault();
  half3 vNormalTS=half3(0,0,1);
  vNormalTS=GetNormalMap(normalsTex,baseTC.xy);
  attribs.Smoothness=MatSpecColor.w*GetSmoothnessTex(smoothnessTex,baseTC.xy);
  attribs.Albedo=MatDifColor.rgb;
  attribs.Albedo*=GetDiffuseTex(diffuseTex,baseTC.xy).rgb;
  attribs.Reflectance=MatSpecColor.rgb;
  attribs.NormalWorld=normalize(mTangentToWS[2]+1e-6);
  attribs.NormalWorld=normalize(mul(vNormalTS,mTangentToWS));
}
float GatherAlpha(float4 baseTC,half vertexAlpha)
{
  half alpha=MatDifColor.w;
  alpha*=GetDiffuseTex(diffuseTex,baseTC.xy).w;
  return alpha;
}
half3 GetEmittanceMask(float2 baseTC)
{
  half4 emittanceMap=GetEmittanceTex(emittanceTex,baseTC.xy);
  emittanceMap.rgb*=pow(max(GetLuminance(emittanceMap.rgb),1e-6),__0EmittanceMapGamma__1__2__3.x-1);
  emittanceMap.rgb=max(emittanceMap.rgb*emittanceMap.a,0);
  return emittanceMap.rgb;
}
void Callback_ShadingDirect(in ForwardShadingAttribs attribs,in ForwardLightParams light,out float3 diffuseAcc,out float3 specularAcc)
{
  float3 viewVec=normalize(-attribs.worldPos);
  float NdotL=saturate(dot(attribs.normal,light.lightVec));
  if(light.type==8)
  {
    AreaLightLTC_GGX(attribs.normal,-normalize(attribs.areaAttribs.position),attribs.smoothness,attribs.reflectance,attribs.areaAttribs.position,attribs.areaAttribs.lightPos,attribs.areaAttribs.lightArrayIdx,attribs.areaAttribs.transform,Fwd_SpotTexArray,diffuseAcc,specularAcc);
  }
  else
  {
    diffuseAcc.x=DiffuseBRDF(attribs.normal,viewVec,light.lightVec,attribs.smoothness,NdotL);
    specularAcc=SpecularBRDF(attribs.normal,viewVec,light.lightVec,attribs.smoothness,attribs.reflectance)*NdotL;
  }
  diffuseAcc=diffuseAcc.x*light.illuminance;
  specularAcc=specularAcc*light.illuminance;
}
cbuffer CBPerPassForward:register(b0, space3)
{
  struct
  {
    float4 vfParams;
    float4 vfRampParams;
    float4 vfSunDir;
    float3 vfColGradBase;
    float padding0;
    float3 vfColGradDelta;
    float padding1;
    float4 vfColGradParams;
    float4 vfColGradRadial;
    float4 vfShadowDarkening;
    float4 vfShadowDarkeningSunAmb;
  }
  cbFog;
  struct
  {
    float4 vfSamplingParams;
    float4 vfDistributionParams;
    float4 vfScatteringParams;
    float4 vfScatteringBlendParams;
    float4 vfScatteringColor;
    float4 vfScatteringSecondaryColor;
    float4 vfHeightDensityParams;
    float4 vfHeightDensityRampParams;
    float4 vfDistanceParams;
    float4 vfGlobalEnvProbeParams0;
    float4 vfGlobalEnvProbeParams1;
  }
  cbVoxelFog;
  struct
  {
    float4x4 TexGen0;
    float4x4 TexGen1;
    float4x4 TexGen2;
    float4x4 TexGen3;
    float4 vInvShadowMapSize;
    float4 fDepthTestBias;
    float4 fOneDivFarDist;
    float4 fKernelRadius;
    float4 CloudShadowParams;
    float4 CloudShadowAnimParams;
    float4 irreg_kernel_2d[8];
  }
  cbShadowSampling;
  struct
  {
    float4 CloudShadingColorSun;
    float4 CloudShadingColorSky;
  }
  cbClouds;
  struct
  {
    float4 IntegrationMode;
  }
  cbSVOGI;
};
Buffer<uint>Fwd_TileLightMask:register(t2, space3);
StructuredBuffer<STiledLightShadeInfo>Fwd_TiledLightsShadeInfo:register(t3, space3);
uint4 GetResourceIndexAndMipClamps(uint resIndex)
{
  const uint resIndexID=(resIndex&0xFFFF);
  const uint resMipClamp0=(resIndex>>16)&0xFF;
  const uint resMipClamp1=(resIndex>>24)&0xFF;
  return uint4(resIndexID,resMipClamp0,resMipClamp1,0.0f);
}
void ApplyGI(inout float3 specularAcc,inout float3 diffuseAcc,float3 diffuseForwAcc,uint2 pixelCoord,float3 surfGloss,float3 surfSpecCol,Texture2D<float4>TexGiDiffuse,Texture2D<float4>TexGiSpecular,SamplerState samplerTrilinearClamp,const int nIntegrMode,float4 fParms)
{
  if(nIntegrMode==0)
  {
    float4 vSkyLightIrradiance=TexGiDiffuse[pixelCoord];
    specularAcc*=lerp(vSkyLightIrradiance.xyz,1.f,surfGloss*GetLuminance(surfSpecCol));
    diffuseAcc*=vSkyLightIrradiance.xyz;
  }
  else if(nIntegrMode==1)
  {
    float3 diffuseIrradiance=TexGiDiffuse[pixelCoord];
    specularAcc*=lerp(min(2.f,GetLuminance(diffuseIrradiance)/(GetLuminance(diffuseAcc+diffuseForwAcc)+0.001)),1.f,saturate(surfGloss*GetLuminance(surfSpecCol)*fParms.x))*fParms.z;
    diffuseAcc=diffuseIrradiance;
  }
  else if(nIntegrMode==2)
  {
    diffuseAcc=TexGiDiffuse[pixelCoord];
    specularAcc=TexGiSpecular[pixelCoord];
  }
  }
int GetNextTileLightIndex(uint lightMask,int startIndex)
{
  uint mask=startIndex<31?~((1<<(startIndex+1))-1):0;
  return firstbitlow(lightMask&mask);
}
void TiledForwardShading(in ForwardShadingAttribs attribs,inout float3 diffuseAcc,inout float3 specularAcc,SamplerState ssTrilinearClamp,SamplerComparisonState ssComparison,const bool shadowHighQualityFiltering,const bool applyProbes,const bool applyNonProbes,const bool bSkipSpecularProbes=false,const bool bOpaque=false)
{
  uint2 numTiles=ceil(CV_ScreenSize.xy/float2(8,8));
  float2 tcProj=attribs.screenUV;
  uint2 tileIdx=uint2(tcProj.x*numTiles.x,tcProj.y*numTiles.y);
  uint bufferIdx=(tileIdx.y*numTiles.x+tileIdx.x)*8;
  float probeWeightSum=0;
  float3 viewVec=-normalize(attribs.worldPos);
  float specCubeLod=6-attribs.smoothness*6;
  float NdotV=saturate(dot(viewVec,attribs.normalSpecProbe));
  float3 envFresnel=GetEnvmapFresnel(attribs.reflectance,attribs.smoothness,NdotV);
  float2 envBRDF=Fwd_EnvironmentBRDF.SampleLevel(ssTrilinearClamp,float2(NdotV,attribs.smoothness),0).xy;
  envFresnel=lerp(envBRDF.xxx,envBRDF.yyy,attribs.reflectance);
  float2 occlusion=float2(1,1);
  float occlSpec=1;
  if(bOpaque)
  {
    float aoAmount=Fwd_RandomRotations[attribs.screenUV*CV_ScreenSize.xy].w;
    float occlDiff=saturate(1-aoAmount*1.0);
    occlSpec=saturate(1-aoAmount*1.5);
    occlusion.x=occlDiff*occlDiff;
    occlusion.y=DeriveSpecularOcclusion(NdotV,max(occlSpec*occlSpec,0.3),attribs.smoothness);
  }
  int lightIndex=-1;
  uint maskIndex=0;
  uint curMask=Fwd_TileLightMask[bufferIdx];
  [loop]for(;
  ;
  )
  {
    while(maskIndex<8)
    {
      lightIndex=GetNextTileLightIndex(curMask,lightIndex);
      if(lightIndex>=0)break;
      else curMask=Fwd_TileLightMask[++maskIndex+bufferIdx];
    }
    uint lightShadeInfoIdx=lightIndex+maskIndex*32;
    int lightType=Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].lightType;
    [branch]if(lightIndex<0||lightType>4)break;
    if(applyProbes)
    {
      const float clipVolumeWeight=1;
      if(lightType==1&&probeWeightSum<1&&clipVolumeWeight>0)
      {
        float3 lightVec=Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].posRad.xyz-(attribs.worldPos+GetWorldViewPos());
        float3 tmpLightVec;
        tmpLightVec.x=dot(Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].projectorMatrix[0].xyz,lightVec);
        tmpLightVec.y=dot(Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].projectorMatrix[1].xyz,lightVec);
        tmpLightVec.z=dot(Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].projectorMatrix[2].xyz,lightVec);
        [branch]if(abs(tmpLightVec.x)<1&&abs(tmpLightVec.y)<1&&abs(tmpLightVec.z)<1)
        {
          tmpLightVec=MapCubeToSphere(tmpLightVec);
          float4 lightColor=Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].color;
          float attenuation=GetAttenuation(tmpLightVec,1,true,Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].attenuationParams.y)*Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].attenuationParams.x;
          uint4 resIndexClamps=GetResourceIndexAndMipClamps(Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].resIndex);
          float probeWeight=(1-probeWeightSum)*attenuation;
          float4 diffuseProbe=Fwd_DiffuseCubeArray.SampleLevel(ssTrilinearClamp,float4(attribs.normal,resIndexClamps.x),resIndexClamps.y);
          diffuseProbe.rgb=DecodeHDRCubemap(diffuseProbe);
          diffuseAcc+=diffuseProbe.rgb*(lightColor.rgb*probeWeight)*occlusion.x;
          if(!bSkipSpecularProbes)
          {
            float tmpGloss=0;
            float3 tmpReflVec=reflect(-viewVec,attribs.normalSpecProbe);
            CubemapBoxParallaxCorrection(tmpReflVec,lightVec,Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].shadowMatrix[0].xyz,Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].shadowMatrix[1].xyz,tmpGloss);
            float4 specularProbe=Fwd_SpecCubeArray.SampleLevel(ssTrilinearClamp,float4(tmpReflVec,resIndexClamps.x),max(resIndexClamps.z,specCubeLod));
            specularProbe.rgb=DecodeHDRCubemap(specularProbe)*envFresnel;
            specularAcc+=specularProbe.rgb*(lightColor.rgb*probeWeight)*occlusion.y*lightColor.a;
          }
          probeWeightSum+=probeWeight;
        }
        }
      }
    }
  if(bOpaque)
  {
    ApplyGI(specularAcc,diffuseAcc,diffuseAcc,int2(attribs.screenUV*CV_ScreenSize.xy),attribs.smoothness,attribs.reflectance,Fwd_GiDiffuseRT,Fwd_GiSpecularRT,ssTrilinearClamp,(int)(cbSVOGI.IntegrationMode.y),cbSVOGI.IntegrationMode);
  }
  [loop]for(;
  ;
  )
  {[branch]if(lightIndex<0)break;
    uint lightShadeInfoIdx=lightIndex+maskIndex*32;
    int lightType=Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].lightType;
    const float3 position=attribs.worldPos;
    const float4 posRad=Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].posRad;
    const float3 lightVec=posRad.xyz-(position+GetWorldViewPos());
    if(applyNonProbes&&lightType>4&&length(lightVec)<posRad.w)
    {
      bool skipShading=false;
      bool shadowMap=false;
      ForwardLightParams lightParams;
      lightParams.type=lightType;
      lightParams.lightVec=normalize(lightVec);
      lightParams.illuminance=Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].color.rgb;
      float attenuation=GetPhysicalLightAttenuation(length(lightVec),rcp(posRad.w),Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].attenuationParams.x);
      lightParams.illuminance*=attenuation;
      const float clipVolumeWeight=1;
      if(lightType==6)
      {
        if(attenuation>0)
        {
          float4 projTC=mul(Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].projectorMatrix,float4(position+GetWorldViewPos(),1.0f));
          projTC.xy/=projTC.w;
          if(projTC.w<0||min(projTC.x,projTC.y)<0||max(projTC.x,projTC.y)>1)skipShading=true;
          else
          {
            uint4 resIndexClamps=GetResourceIndexAndMipClamps(Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].resIndex);
            lightParams.illuminance*=Fwd_SpotTexArray.SampleLevel(ssTrilinearClamp,float3(projTC.xy,resIndexClamps.x),resIndexClamps.y).xxx;
          }
          if(Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].shadowParams.x>0)shadowMap=true;
        }
        }
      else if(lightType==7)
      {
        uint cubeFace=selectCubeFace(lightVec);
        skipShading=(Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].resIndex!=cubeFace);
        shadowMap=true;
      }
      if(!skipShading)
      {
        float shadowOccl=1;
        if(shadowMap)
        {
          float4 P0=mul(Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].shadowMatrix,float4(position+GetWorldViewPos(),1));
          P0.xy/=P0.w;
          P0.z-=Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].shadowParams.y;
          bool bAllowHighQualityShadows=false;
          if(bOpaque)
          {
            int3 sampleCoords=int3(attribs.screenUV*CV_ScreenSize.xy,Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].shadowMaskIndex);
            shadowOccl=1-Fwd_SunShadowMask[sampleCoords];
          }
          else if(shadowHighQualityFiltering&&bAllowHighQualityShadows)
          {
            float2 kernelRadius=Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].shadowParams.x;
            float2 rotScale=kernelRadius.y*1000.0f;
            const int nRotationTextureSize=64;
            int2 sampleCoords=int2(P0.xy*rotScale.xy*nRotationTextureSize)% nRotationTextureSize;
            half2 rotSample=Fwd_RandomRotations.Load(int3(sampleCoords,0)).xy;
            rotSample.xy*=kernelRadius.xy*1/512.0f;
            float4 rot=float4(rotSample.x,-rotSample.y,rotSample.y,rotSample.x);
            shadowOccl=0;
            for(int s=0;
            s<16/2;
            s+=2)
            {
              half4 sampleDepth;
              
              {
                float4 rotatedOff0=rot.xyzw*irreg_kernel_2d[s+0].xxww+rot.zwxy*irreg_kernel_2d[s+0].yyzz;
                float4 rotatedOff1=rot.xyzw*irreg_kernel_2d[s+1].xxww+rot.zwxy*irreg_kernel_2d[s+1].yyzz;
                sampleDepth.x=Fwd_ShadowPool.SampleCmpLevelZero(ssComparison,P0.xy+rotatedOff0.xy,P0.z);
                sampleDepth.y=Fwd_ShadowPool.SampleCmpLevelZero(ssComparison,P0.xy+rotatedOff0.zw,P0.z);
                sampleDepth.z=Fwd_ShadowPool.SampleCmpLevelZero(ssComparison,P0.xy+rotatedOff1.xy,P0.z);
                sampleDepth.w=Fwd_ShadowPool.SampleCmpLevelZero(ssComparison,P0.xy+rotatedOff1.zw,P0.z);
              }
              shadowOccl+=dot(sampleDepth,1.0/16);
            }
            }
          else
          {
            shadowOccl=Fwd_ShadowPool.SampleCmpLevelZero(ssComparison,P0.xy,P0.z);
          }
          }
        lightParams.illuminance*=shadowOccl;
        float3 diffuseTerm=0;
        float3 specularTerm=0;
        attribs.areaAttribs.transform=Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].projectorMatrix;
        attribs.areaAttribs.lightPos=Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].posRad.xyz-GetWorldViewPos();
        attribs.areaAttribs.position=position;
        attribs.areaAttribs.lightArrayIdx=GetResourceIndexAndMipClamps(Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].resIndex).x;
        Callback_ShadingDirect(attribs,lightParams,diffuseTerm,specularTerm);
        diffuseAcc+=diffuseTerm;
        specularAcc+=specularTerm;
      }
      }
    while(maskIndex<8)
    {
      lightIndex=GetNextTileLightIndex(curMask,lightIndex);
      if(lightIndex>=0)break;
      else curMask=Fwd_TileLightMask[++maskIndex+bufferIdx];
    }
    }
  }
SFogParams GetFogParams()
{
  SFogParams params;
  params.viewPos.xyz=float3(CV_ScreenToWorldBasis[0][3],CV_ScreenToWorldBasis[1][3],CV_ScreenToWorldBasis[2][3]).xyz;
  params.padding0=0.0f;
  params.heightDensityScale=cbFog.vfParams.x;
  params.heightDensityAtBaseHeight=cbFog.vfParams.y;
  params.heightDiffFromBase=cbFog.vfParams.z;
  params.expHeightDiffFromBase=cbFog.vfParams.w;
  params.rampParams=cbFog.vfRampParams;
  params.sunDir=cbFog.vfSunDir.xyz;
  params.densityClamp=cbFog.vfSunDir.w;
  params.colGradBase=cbFog.vfColGradBase;
  params.padding1=0.0f;
  params.colGradDelta=cbFog.vfColGradDelta;
  params.padding2=0.0f;
  params.heightColGradScale=cbFog.vfColGradParams.x;
  params.heightColGradOffset=cbFog.vfColGradParams.y;
  params.radialSizeCtrl=cbFog.vfColGradParams.z;
  params.radialLobeCtrl=cbFog.vfColGradParams.w;
  params.radialColor=cbFog.vfColGradRadial.xyz;
  params.invZFar=cbFog.vfColGradRadial.w;
  return params;
}
SVolumetricFogParams GetVolumetricFogParams()
{
  SVolumetricFogParams params;
  params.sunDir=CV_SunLightDir.xyz;
  params.padding0=0.0f;
  params.nearDist=cbVoxelFog.vfSamplingParams.x;
  params.invFarMinusNearDist=cbVoxelFog.vfSamplingParams.y;
  params.maxIndex=cbVoxelFog.vfSamplingParams.z;
  params.invMaxIndex=cbVoxelFog.vfSamplingParams.w;
  params.screenSize=CV_ScreenSize.xy;
  params.farMinusNearDist=cbVoxelFog.vfDistributionParams.y;
  params.invMaxIndexMinusOne=cbVoxelFog.vfDistributionParams.z;
  params.viewPos=float3(CV_ScreenToWorldBasis[0][3],CV_ScreenToWorldBasis[1][3],CV_ScreenToWorldBasis[2][3]).xyz;
  params.framwCountJitter=cbVoxelFog.vfDistributionParams.w;
  params.scatterCoefficient=cbVoxelFog.vfScatteringParams.x;
  params.extinctionCoefficient=cbVoxelFog.vfScatteringParams.y;
  params.blendFactor=cbVoxelFog.vfScatteringBlendParams.x;
  params.blendMode=cbVoxelFog.vfScatteringBlendParams.y;
  params.cDiffuse1=cbVoxelFog.vfScatteringColor.xyz;
  params.padding1=0.0f;
  params.cDiffuse2=cbVoxelFog.vfScatteringSecondaryColor.xyz;
  params.padding2=0.0f;
  params.anisotropy1.x=cbVoxelFog.vfScatteringParams.z;
  params.anisotropy1.y=cbVoxelFog.vfScatteringParams.w;
  params.anisotropy2.x=cbVoxelFog.vfScatteringColor.w;
  params.anisotropy2.y=cbVoxelFog.vfScatteringSecondaryColor.w;
  params.heightDensityScale=cbVoxelFog.vfHeightDensityParams.x;
  params.densityAtViewer=cbVoxelFog.vfHeightDensityParams.y;
  params.fogVisibility=cbVoxelFog.vfHeightDensityParams.z;
  params.clampTransmittance=cbVoxelFog.vfHeightDensityParams.w;
  params.rampStart=cbVoxelFog.vfHeightDensityRampParams.x;
  params.rampEnd=cbVoxelFog.vfHeightDensityRampParams.y;
  params.oneOverRampDiff=cbVoxelFog.vfHeightDensityRampParams.z;
  params.rampStartOverRampDiff=cbVoxelFog.vfHeightDensityRampParams.w;
  params.farDistTopLeft=cbVoxelFog.vfDistanceParams.x;
  params.farDistTopCenter=cbVoxelFog.vfDistanceParams.y;
  params.farDistCenterLeft=cbVoxelFog.vfDistanceParams.z;
  params.farDistCenter=cbVoxelFog.vfDistanceParams.w;
  params.timeParams.x=CV_AnimGenParams.z;
  params.timeParams.y=CV_AnimGenParams.z*0.5f;
  params.timeParams.z=CV_AnimGenParams.y;
  params.timeParams.w=CV_AnimGenParams.w;
  return params;
}
VolumetricFogSampling GetVolumetricFogSampling()
{
  VolumetricFogSampling vfs;
  vfs.volumetricFogTex=Fwd_volFogTex;
  vfs.globalEnvProbeTex0=Fwd_volFogEnvTex0;
  vfs.globalEnvProbeTex1=Fwd_volFogEnvTex1;
  vfs.trilinearClampSState=ssMaterialTrilinearClamp;
  return vfs;
}
void Fwd_ApplyFog(in float3 worldPos,in float3 cameraToWorldPos,in float4 WPos,inout float3 color)
{
  SFogParams params=GetFogParams();
  half4 localFogColor=GetVolumetricFogColor(params,worldPos,cameraToWorldPos);
  color.xyz=lerp(localFogColor.xyz,color.xyz,saturate(localFogColor.w));
}
void Fwd_ApplyFog(in float4 localFogColor,in float4 WPos,inout float3 color)
{
  color.xyz=lerp(localFogColor.xyz,color.xyz,saturate(localFogColor.w));
}
void Fwd_StandardOpaqueShading(in MaterialAttribsCommon commonAttribs,inout ForwardShadingAttribs fwdAttribs,inout half3 diffuseAcc,inout half3 specularAcc,bool bSunShadows=true)
{
  fwdAttribs.normal=commonAttribs.NormalWorld;
  fwdAttribs.normalSpecProbe=fwdAttribs.normal;
  fwdAttribs.reflectance=commonAttribs.Reflectance;
  fwdAttribs.albedo=commonAttribs.Albedo;
  fwdAttribs.smoothness=commonAttribs.Smoothness;
  fwdAttribs.areaAttribs=(AreaLightShadingAttribs)0;
  
  {
    float shadowMask=0;
    ForwardLightParams lightParams;
    lightParams.type=9;
    lightParams.lightVec=CV_SunLightDir.xyz;
    lightParams.illuminance=CV_SunColor.xyz*(1-shadowMask);
    Callback_ShadingDirect(fwdAttribs,lightParams,diffuseAcc,specularAcc);
  }
  
  {
    diffuseAcc+=Fwd_GlobalProbe.SampleLevel(ssMaterialTrilinear,fwdAttribs.normal,8);
    float3 viewVec=normalize(-fwdAttribs.worldPos);
    float NdotV=saturate(dot(viewVec,fwdAttribs.normal));
    specularAcc+=GetEnvironmentCMap(Fwd_GlobalProbe,ssMaterialTrilinearClamp,reflect(-viewVec,fwdAttribs.normal),fwdAttribs.smoothness)*GetEnvmapFresnel(fwdAttribs.reflectance,fwdAttribs.smoothness,NdotV);
  }
  diffuseAcc*=fwdAttribs.albedo*saturate(1-GetLuminance(fwdAttribs.reflectance));
}
pixout IlluminationPS(vert2FragGeneral IN)
{
  pixout OUT=(pixout)0;
  half3 emittance=MatEmissiveColor.xyz*MatEmissiveColor.w*(1000.0/10000.0);
  const bool bEmissive=GetLuminance(emittance.xyz)>0;
  if(bEmissive)
  {
    emittance*=GetEmittanceMask(IN.baseTC);
  }
  MaterialAttribsCommon commonAttribs;
  half3x3 mTangentToWS=half3x3(IN.vTangent.xyz,IN.vBinormal.xyz,cross(IN.vTangent.xyz,IN.vBinormal.xyz)*IN.vTangent.w);
  half4 vertexColor=0;
  GatherMaterialAttribs(mTangentToWS,IN.baseTC.xy,vertexColor,commonAttribs);
  ForwardShadingAttribs fwdAttribs;
  fwdAttribs.screenUV=IN.screenProj.xy/IN.screenProj.w;
  fwdAttribs.worldPos=IN.vView.xyz;
  float3 diffuseAcc=0,specularAcc=0;
  const bool bSunShadows=true;
  Fwd_StandardOpaqueShading(commonAttribs,fwdAttribs,diffuseAcc,specularAcc,bSunShadows);
  OUT.Color.rgb=diffuseAcc+specularAcc+emittance;
  OUT.Color.a=1;
  const float3 worldPos=IN.vView.xyz+GetWorldViewPos();
  Fwd_ApplyFog(worldPos.xyz,IN.vView.xyz,IN.WPos,OUT.Color.rgb);
  return OUT;
}