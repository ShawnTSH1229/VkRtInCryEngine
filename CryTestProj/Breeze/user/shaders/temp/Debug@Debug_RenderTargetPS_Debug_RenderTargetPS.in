/*
BgAAAHBzXzZfMAAAFAAAAERlYnVnX1JlbmRlclRhcmdldFBTAgIQAAAAQEAQAAAAgEABEQAAAABAzMzMAAAAAAAAAAA=
*/

SamplerState smpBaseMap:register(s1, space0);
Texture2D texBaseMap:register(t0, space0);
struct pixout
{
  half4 Color:SV_Target0;
};
cbuffer CBPerViewGlobal:register(b6)
{
  float4x4 CV_ViewProjZeroMatr;
  float4 CV_AnimGenParams;
  float4x4 CV_ViewProjMatr;
  float4x4 CV_ViewProjNearestMatr;
  float4x4 CV_InvViewProj;
  float4x4 CV_PrevViewProjMatr;
  float4x4 CV_PrevViewProjNearestMatr;
  float3x4 CV_ScreenToWorldBasis;
  float4 CV_TessInfo;
  float4 CV_WorldViewPosition;
  float4 CV_CameraRightVector;
  float4 CV_CameraFrontVector;
  float4 CV_CameraUpVector;
  float4 CV_ScreenSize;
  float4 CV_HPosScale;
  float4 CV_ProjRatio;
  float4 CV_NearestScaled;
  float4 CV_NearFarClipDist;
  float4 CV_SunLightDir;
  float4 CV_SunColor;
  float4 CV_SkyColor;
  float4 CV_FogColor;
  float4 CV_TerrainInfo;
  float4 CV_DecalZFightingRemedy;
  float4x4 CV_FrustumPlaneEquation;
  float4 CV_WindGridOffset;
  float4x4 CV_ViewMatr;
  float4x4 CV_InvViewMatr;
  float4x4 CV_ProjMatr;
  float4x4 CV_ProjMatrUnjittered;
};
cbuffer CBPerPassShadowGen:register(b5)
{
  float4 CP_ShadowGen_LightPos;
  float4 CP_ShadowGen_ViewPos;
  float4 CP_ShadowGen_DepthTestBias;
  float4 CP_ShadowGen_FrustumInfo;
  float4 CP_ShadowGen_VegetationAlphaClamp;
};
cbuffer CBPerPassCustom:register(b5)
{
  float4 CP_Custom_ViewMode;
};
cbuffer CB_SkinQuat_Cur:register(b2)
{
  float2x4 _g_SkinQuat_Cur[768];
};
cbuffer CB_SkinQuat_Prev:register(b3)
{
  float2x4 _g_SkinQuat_Prev[768];
};
half4 GetTexture2D(Texture2D tex,SamplerState samplerState,float2 uv)
{
  return tex.Sample(samplerState,uv);
}
half4 DecodeRGBK(in half4 Color,const half fMultiplier,bool bUsePPP=false)
{
  if(bUsePPP)
  {
    Color.rgb*=(Color.a*Color.a)*fMultiplier;
  }
  else Color.rgb*=Color.a*fMultiplier;
  return Color;
}
half4 Decode7E3F(in half4 color)
{
  float3 me=color.xyz;
  float3 e=floor(me);
  float3 m=frac(me);
  color.xyz=select((e==0.F),2.F*m,(1.F+m)*exp2(e));
  color.xyz*=0.125f;
  return color;
}
struct vert2frag
{
  float4 HPosition:SV_POSITION;
  float2 baseTC:TEXCOORD0;
};
cbuffer CBDebugRenderTarget:register(b0, space1)
{
  struct
  {
    float4 colorMultiplier;
    float4 showRTFlags;
    float4 transform;
  }
  cbDebugRenderTarget;
};
pixout Debug_RenderTargetPS(vert2frag IN)
{
  pixout OUT=(pixout)0;
  const float onlyAlpha=cbDebugRenderTarget.showRTFlags.x;
  const float RGBKEncoded=cbDebugRenderTarget.showRTFlags.y;
  const float aliased=cbDebugRenderTarget.showRTFlags.z;
  half4 color=GetTexture2D(texBaseMap,smpBaseMap,IN.baseTC.xy);
  if(RGBKEncoded>0.5f)
  {
    color.rgb=DecodeRGBK(color,32.h,false);
  }
  else if(aliased>0.5f)
  {
    color.rgb=Decode7E3F(color).rgb;
  }
  color*=cbDebugRenderTarget.colorMultiplier;
  OUT.Color=lerp(color,color.wwww,onlyAlpha);
  return OUT;
}