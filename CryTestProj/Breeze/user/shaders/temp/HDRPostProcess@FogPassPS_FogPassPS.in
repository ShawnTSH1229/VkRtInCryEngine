/*
BgAAAHBzXzZfMAAACQAAAEZvZ1Bhc3NQUwAAAAMCEAAAAEBAEAAAAIBAAREAAAAARgEQAAAAAEAAAAAAAAAAAA==
*/

cbuffer PER_BATCH:register(b0, space2)
{
  float4 vfHeightDensityRampParams;
  float4 vfScatteringParams;
  //vfGlobalEnvProbeParams0;
  //NumInstructions;
  float4 vfScatteringBlendParams;
  float4 vfScatteringColor;
  float4 vfDistributionParams;
  float4 vfSamplingParams;
  float3 vfColGradDelta;
  float4 vfRampParams;
  float4 vfColGradRadial;
  //vfGlobalEnvProbeParams1;
  float4 PS_NearFarClipDist;
  float4 vfColGradParams;
  float4 volFogShadowBufSampleOffsets[8];
  float4 vfHeightDensityParams;
  float4 SVO_AirTextureScale;
  //volFogShadowDarkeningSunAmb;
  float4 PS_ScreenSize;
  float3 vfColGradBase;
  //volFogShadowRange;
  float4 vfDistanceParams;
  float4 vfParams;
  float4 vfTimeParams;
  //volFogShadowDarkening;
  float4 vfScatteringSecondaryColor;
  float4 vfSunDir;
  float4 vfViewPos;
};
SamplerState FOG_SStatePC:register(s1, space0);
SamplerState volFogPointSamplerState:register(s1, space0);
SamplerState vfTrilinearClampSState;
SamplerState volFogTrilinearClampSState:register(s1, space0);
Texture3D<float4>VolumetricFogTexture;
TextureCube<float4>volFogGlobalEnvProbeTex0:register(t2);
Texture2D FOG_smp_Air_RGBA_Max:register(t14);
Texture3D<float4>volFogSamplingTex:register(t1);
TextureCube<float4>volFogGlobalEnvProbeTex1:register(t3);
Texture2D FOG_smp_Air_RGBA_Min:register(t12);
Texture2D<float4>zMap:register(t0, space0);
Texture2D FOG_smp_Air_Depths:register(t13);
TextureCube<float4>vfGlobalEnvProbeTexture1:register(t26);
Texture2D<float2>volFogShadowTex:register(t1);
Texture2DMS<float4>zMapMS:register(t0, space0);
TextureCube<float4>vfGlobalEnvProbeTexture0:register(t25);
struct pixout
{
  half4 Color:SV_Target0;
};
cbuffer CBPerViewGlobal:register(b0, space1)
{
  float4x4 CV_ViewProjZeroMatr;
  float4 CV_AnimGenParams;
  float4x4 CV_ViewProjMatr;
  float4x4 CV_ViewProjNearestMatr;
  float4x4 CV_InvViewProj;
  float4x4 CV_PrevViewProjMatr;
  float4x4 CV_PrevViewProjNearestMatr;
  float3x4 CV_ScreenToWorldBasis;
  float4 CV_TessInfo;
  float4 CV_WorldViewPosition;
  float4 CV_CameraRightVector;
  float4 CV_CameraFrontVector;
  float4 CV_CameraUpVector;
  float4 CV_ScreenSize;
  float4 CV_HPosScale;
  float4 CV_ProjRatio;
  float4 CV_NearestScaled;
  float4 CV_NearFarClipDist;
  float4 CV_SunLightDir;
  float4 CV_SunColor;
  float4 CV_SkyColor;
  float4 CV_FogColor;
  float4 CV_TerrainInfo;
  float4 CV_DecalZFightingRemedy;
  float4x4 CV_FrustumPlaneEquation;
  float4 CV_WindGridOffset;
  float4x4 CV_ViewMatr;
  float4x4 CV_InvViewMatr;
  float4x4 CV_ProjMatr;
  float4x4 CV_ProjMatrUnjittered;
};
cbuffer CBPerPassShadowGen:register(b5)
{
  float4 CP_ShadowGen_LightPos;
  float4 CP_ShadowGen_ViewPos;
  float4 CP_ShadowGen_DepthTestBias;
  float4 CP_ShadowGen_FrustumInfo;
  float4 CP_ShadowGen_VegetationAlphaClamp;
};
cbuffer CBPerPassCustom:register(b5)
{
  float4 CP_Custom_ViewMode;
};
cbuffer CB_SkinQuat_Cur:register(b2)
{
  float2x4 _g_SkinQuat_Cur[768];
};
cbuffer CB_SkinQuat_Prev:register(b3)
{
  float2x4 _g_SkinQuat_Prev[768];
};
half4 GetTexture2D(Texture2D tex,SamplerState samplerState,float2 uv)
{
  return tex.Sample(samplerState,uv);
}
float GetLinearDepth(float fDevDepth,bool bScaled=false)
{
  return fDevDepth*(bScaled?PS_NearFarClipDist.y:1.0f);
}
float GetLinearDepth(Texture2D depthTexture,int2 vPixCoord,bool bScaled=false)
{
  float fDepth=depthTexture.Load(int3(vPixCoord,0)).x;
  return GetLinearDepth(fDepth,bScaled);
}
float GetLinearDepth(Texture2D depthTexture,float2 ScreenTC,bool bScaled=false)
{
  int2 vPixCoord=int2(ScreenTC*PS_ScreenSize.xy);
  return GetLinearDepth(depthTexture,vPixCoord,bScaled);
}
float3 ReconstructWorldPos(int2 WPos,float linearDepth,bool bRelativeToCamera=false)
{
  float4 wposScaled=float4(WPos*linearDepth,linearDepth,bRelativeToCamera?0.0:1.0);
  return mul(CV_ScreenToWorldBasis,wposScaled);
}
float3 ReconstructWorldPos(int2 WPos,Texture2D sceneDepthTex,bool bRelativeToCamera=false)
{
  float linearDepth=sceneDepthTex.Load(int3(WPos,0)).x;
  return ReconstructWorldPos(WPos,linearDepth,bRelativeToCamera);
}
float3 GetWorldViewPos()
{
  return float3(CV_ScreenToWorldBasis[0][3],CV_ScreenToWorldBasis[1][3],CV_ScreenToWorldBasis[2][3]);
}
int GetMSAASampleNum()
{
  int nSamplesNum=0;
  return nSamplesNum;
}
float2 MapViewportToRaster(float2 normalizedViewportPos,bool bOtherEye=false)
{
  return normalizedViewportPos;
}
static const float LTC_LUT_SIZE=64.0f;
static const float LTC_LUT_SCALE=(LTC_LUT_SIZE-1.0f)/LTC_LUT_SIZE;
static const float LTC_LUT_BIAS=0.5f/LTC_LUT_SIZE;
half4 DecodeHDRCubemap(half4 color)
{
  return color;
}
void HDROutput(out pixout OUT,half4 Color,half fDepth)
{
  OUT.Color=Color;
}
struct SFogParams
{
  float3 viewPos;
  float padding0;
  float heightDensityScale;
  float heightDensityAtBaseHeight;
  float heightDiffFromBase;
  float expHeightDiffFromBase;
  float4 rampParams;
  float3 sunDir;
  float densityClamp;
  float3 colGradBase;
  float padding1;
  float3 colGradDelta;
  float padding2;
  float heightColGradScale;
  float heightColGradOffset;
  float radialSizeCtrl;
  float radialLobeCtrl;
  float3 radialColor;
  float invZFar;
};
SFogParams GetFogParamsInternal()
{
  SFogParams params;
  params.viewPos.xyz=GetWorldViewPos();
  params.padding0=0.0f;
  params.heightDensityScale=vfParams.x;
  params.heightDensityAtBaseHeight=vfParams.y;
  params.heightDiffFromBase=vfParams.z;
  params.expHeightDiffFromBase=vfParams.w;
  params.rampParams=vfRampParams;
  params.sunDir=vfSunDir.xyz;
  params.densityClamp=vfSunDir.w;
  params.colGradBase=vfColGradBase;
  params.padding1=0.0f;
  params.colGradDelta=vfColGradDelta;
  params.padding2=0.0f;
  params.heightColGradScale=vfColGradParams.x;
  params.heightColGradOffset=vfColGradParams.y;
  params.radialSizeCtrl=vfColGradParams.z;
  params.radialLobeCtrl=vfColGradParams.w;
  params.radialColor=vfColGradRadial.xyz;
  params.invZFar=vfColGradRadial.w;
  return params;
}
float ComputeVolumetricFogInternal(in float3 cameraToWorldPos,in SFogParams fogParams)
{
  float fogInt=1.0;
  const float t=fogParams.heightDensityScale*cameraToWorldPos.z;
  if(abs(t)>0.01)
  {
    fogInt*=(exp(t+fogParams.heightDiffFromBase)-fogParams.expHeightDiffFromBase)/t;
  }
  else
  {
    fogInt*=fogParams.expHeightDiffFromBase;
  }
  const float l=length(cameraToWorldPos);
  const float u=l*fogParams.heightDensityAtBaseHeight;
  fogInt*=u;
  float f=saturate(exp2(-fogInt));
  half r=saturate(l*fogParams.rampParams.x+fogParams.rampParams.y);
  r=r*(2-r);
  r=r*fogParams.rampParams.z+fogParams.rampParams.w;
  f=(1-f)*r;
  return max(1-f,fogParams.densityClamp);
}
float4 GetVolumetricFogColorInternal(in float3 worldPos,in float3 cameraToWorldPos,in float radialFogShadowInfluence,in float ambientFogShadowInfluence,in SFogParams fogParams)
{
  const float fog=ComputeVolumetricFogInternal(cameraToWorldPos,fogParams);
  half h=saturate(worldPos.z*fogParams.heightColGradScale+fogParams.heightColGradOffset);
  h=h*(2-h);
  half3 fogColor=(fogParams.colGradBase+h*fogParams.colGradDelta)*ambientFogShadowInfluence;
  const half l=saturate(length(cameraToWorldPos)*fogParams.invZFar);
  const half radialLobe=pow(l,fogParams.radialLobeCtrl);
  const half radialSize=exp2(dot(normalize(cameraToWorldPos),fogParams.sunDir.xyz)*-fogParams.radialSizeCtrl+fogParams.radialSizeCtrl);
  fogColor+=radialLobe*radialSize*fogParams.radialColor*radialFogShadowInfluence;
  return float4(fogColor,fog);
}
float4 GetVolumetricFogColorInternal(in float3 worldPos,in SFogParams fogParams)
{
  const float3 camToWorld=worldPos-fogParams.viewPos.xyz;
  return GetVolumetricFogColorInternal(worldPos,camToWorld,1,1,fogParams);
}
float4 GetVolumetricFogColor(in float3 worldPos,in float3 cameraToWorldPos,in float radialFogShadowInfluence,in float ambientFogShadowInfluence)
{
  const SFogParams fogParams=GetFogParamsInternal();
  return GetVolumetricFogColorInternal(worldPos,cameraToWorldPos,radialFogShadowInfluence,ambientFogShadowInfluence,fogParams);
}
float4 GetVolumetricFogColor(in SFogParams fogParams,in float3 worldPos,in float3 cameraToWorldPos,in float radialFogShadowInfluence,in float ambientFogShadowInfluence)
{
  return GetVolumetricFogColorInternal(worldPos,cameraToWorldPos,radialFogShadowInfluence,ambientFogShadowInfluence,fogParams);
}
float4 GetVolumetricFogColor(in float3 worldPos,in float3 cameraToWorldPos)
{
  const SFogParams fogParams=GetFogParamsInternal();
  return GetVolumetricFogColorInternal(worldPos,cameraToWorldPos,1,1,fogParams);
}
float4 GetVolumetricFogColor(in SFogParams fogParams,in float3 worldPos,in float3 cameraToWorldPos)
{
  return GetVolumetricFogColorInternal(worldPos,cameraToWorldPos,1,1,fogParams);
}
float4 GetVolumetricFogColor(in float3 worldPos)
{
  const SFogParams fogParams=GetFogParamsInternal();
  return GetVolumetricFogColorInternal(worldPos,fogParams);
}
float4 GetVolumetricFogColor(in SFogParams fogParams,in float3 worldPos)
{
  return GetVolumetricFogColorInternal(worldPos,fogParams);
}
struct VolumetricFogLight
{
  float3 cDiffuse;
  float fFallOff;
  float radialLobe;
  float dotLE;
  float k;
  float k2;
};
struct VolumetricFogSunLight
{
  float fFallOff;
  float dotLE;
  float blendFactor;
  float blendMode;
  float3 cDiffuse1;
  float3 cDiffuse2;
  float2 anisotropy1;
  float2 anisotropy2;
};
struct VolumetricFogTexcoord
{
  float3 texcoord;
  float range;
  float linearDepth;
};
struct VolumetricFogSampling
{Texture3D<float4>volumetricFogTex;
  TextureCube<float4>globalEnvProbeTex0;
  TextureCube<float4>globalEnvProbeTex1;
  SamplerState trilinearClampSState;
};
struct SVolumetricFogParams
{
  float3 sunDir;
  float padding0;
  float nearDist;
  float invFarMinusNearDist;
  float maxIndex;
  float invMaxIndex;
  float2 screenSize;
  float farMinusNearDist;
  float invMaxIndexMinusOne;
  float3 viewPos;
  float framwCountJitter;
  float scatterCoefficient;
  float extinctionCoefficient;
  float blendFactor;
  float blendMode;
  float3 cDiffuse1;
  float padding1;
  float3 cDiffuse2;
  float padding2;
  float2 anisotropy1;
  float2 anisotropy2;
  float heightDensityScale;
  float densityAtViewer;
  float fogVisibility;
  float clampTransmittance;
  float rampStart;
  float rampEnd;
  float oneOverRampDiff;
  float rampStartOverRampDiff;
  float farDistTopLeft;
  float farDistTopCenter;
  float farDistCenterLeft;
  float farDistCenter;
  float4 timeParams;
};
SVolumetricFogParams vfGetVolumetricFogParamsInternal()
{
  SVolumetricFogParams params;
  params.sunDir=vfSunDir.xyz;
  params.padding0=0.0f;
  params.nearDist=vfSamplingParams.x;
  params.invFarMinusNearDist=vfSamplingParams.y;
  params.maxIndex=vfSamplingParams.z;
  params.invMaxIndex=vfSamplingParams.w;
  params.screenSize=CV_ScreenSize.xy;
  params.farMinusNearDist=vfDistributionParams.y;
  params.invMaxIndexMinusOne=vfDistributionParams.z;
  params.viewPos=GetWorldViewPos();
  params.framwCountJitter=vfDistributionParams.w;
  params.scatterCoefficient=vfScatteringParams.x;
  params.extinctionCoefficient=vfScatteringParams.y;
  params.blendFactor=vfScatteringBlendParams.x;
  params.blendMode=vfScatteringBlendParams.y;
  params.cDiffuse1=vfScatteringColor.xyz;
  params.padding1=0.0f;
  params.cDiffuse2=vfScatteringSecondaryColor.xyz;
  params.padding2=0.0f;
  params.anisotropy1.x=vfScatteringParams.z;
  params.anisotropy1.y=vfScatteringParams.w;
  params.anisotropy2.x=vfScatteringColor.w;
  params.anisotropy2.y=vfScatteringSecondaryColor.w;
  params.heightDensityScale=vfHeightDensityParams.x;
  params.densityAtViewer=vfHeightDensityParams.y;
  params.fogVisibility=vfHeightDensityParams.z;
  params.clampTransmittance=vfHeightDensityParams.w;
  params.rampStart=vfHeightDensityRampParams.x;
  params.rampEnd=vfHeightDensityRampParams.y;
  params.oneOverRampDiff=vfHeightDensityRampParams.z;
  params.rampStartOverRampDiff=vfHeightDensityRampParams.w;
  params.farDistTopLeft=vfDistanceParams.x;
  params.farDistTopCenter=vfDistanceParams.y;
  params.farDistCenterLeft=vfDistanceParams.z;
  params.farDistCenter=vfDistanceParams.w;
  params.timeParams=vfTimeParams;
  return params;
}
float GetJitterInternal(in uint2 pixelCoord,in float2 temporalJitter)
{
  float2 n=pixelCoord.xy+temporalJitter.xy;
  float3 magic=
  {
    0.06711056f,0.00583715f,52.9829189f};
  float jitter=frac(magic.z*frac(dot(n.xy,magic.xy)));
  return jitter;
}
float GetJitteredTexcoordDepthInternal(in float2 screenPos,in float texcoordDepth,in float invMaxIndex,in float2 time)
{
  float jitter=GetJitterInternal(screenPos.xy,time.xy);
  jitter*=invMaxIndex;
  return(-1.0f*jitter)+texcoordDepth;
}
float GetVolumetricFogInscatteringSchlickPhaseFunction(float dotLE,float k,float oneMinusK2)
{
  const float k2=oneMinusK2;
  float h=-((k*dotLE)-1.0f);
  return(k2/(4.0f*3.1415*h*h));
}
float GetVolumetricFogInscatteringSideRadialPhaseFunction(float dotLE)
{
  float factor=(1.0f-abs(dotLE));
  return(factor*(1.0f/(3.1415*3.1415)));
}
float3 GetVolumetricFogInscattering(in VolumetricFogLight light,bool isotoropic)
{
  float phaseFunc;
  if(isotoropic)
  {
    phaseFunc=1.0f/(4.0f*3.1415);
  }
  else
  {
    const float dotLE=light.dotLE;
    float mainRadialLobe=GetVolumetricFogInscatteringSchlickPhaseFunction(dotLE,light.k,light.k2);
    float sideRadialLobe=GetVolumetricFogInscatteringSideRadialPhaseFunction(dotLE);
    phaseFunc=lerp(mainRadialLobe,sideRadialLobe,light.radialLobe);
  }
  const float attenuation=phaseFunc*light.fFallOff;
  return attenuation*light.cDiffuse;
}
float3 GetVolumetricFogInscatteringSun(in VolumetricFogSunLight light)
{
  const float primaryPhaseFunc=GetVolumetricFogInscatteringSchlickPhaseFunction(light.dotLE,light.anisotropy1.x,light.anisotropy1.y);
  const float secondaryPhaseFunct=GetVolumetricFogInscatteringSchlickPhaseFunction(light.dotLE,light.anisotropy2.x,light.anisotropy2.y);
  const float primaryRadiation=primaryPhaseFunc*light.fFallOff;
  const float secondaryRadiation=secondaryPhaseFunct*light.fFallOff;
  const float3 ins0=primaryRadiation*light.cDiffuse1;
  const float3 ins1=secondaryRadiation*light.cDiffuse2;
  return(ins0*(1.0f-(light.blendFactor*light.blendMode)))+(ins1*light.blendFactor);
}
float4 GetVolumetricFogAnalyticalColor(in SVolumetricFogParams params,in VolumetricFogSampling vfs,in float3 cameraToWorldPos,in float lengthToTarget,in bool fullSpan=false)
{
  float3 inscatter=float3(0.0f,0.0f,0.0f);
  float4 diffuseProbe0=float4(0.0f,0.0f,0.0f,0.0f);
  float4 diffuseProbe1=float4(0.0f,0.0f,0.0f,0.0f);
  const float d=lengthToTarget;
  const float L=params.heightDensityScale;
  const float M=cameraToWorldPos.z/d;
  const float volFogDensityAtViewer=params.densityAtViewer;
  const float extinctionCoefficient=params.extinctionCoefficient;
  const float rampStart=params.rampStart;
  const float rampEnd=params.rampEnd;
  const float transitionDistance=fullSpan?0.1f:params.farDistCenter;
  VolumetricFogSunLight vfLight;
  vfLight.dotLE=dot(params.sunDir.xyz,normalize(cameraToWorldPos));
  vfLight.fFallOff=1.0f;
  vfLight.blendFactor=params.blendFactor;
  vfLight.blendMode=params.blendMode;
  vfLight.cDiffuse1=params.cDiffuse1.xyz;
  vfLight.cDiffuse2=params.cDiffuse2.xyz;
  vfLight.anisotropy1.x=params.anisotropy1.x;
  vfLight.anisotropy1.y=params.anisotropy1.y;
  vfLight.anisotropy2.x=params.anisotropy2.x;
  vfLight.anisotropy2.y=params.anisotropy2.y;
  inscatter+=GetVolumetricFogInscatteringSun(vfLight);
  float invExtinction=rcp(extinctionCoefficient);
  inscatter*=params.scatterCoefficient*invExtinction;
  float LM=L*M;
  LM=abs(LM)<0.000001f?0.000001f:LM;
  float invLM=rcp(LM);
  float cLM=-extinctionCoefficient*volFogDensityAtViewer*invLM;
  float d2=min(transitionDistance,d);
  float minD=min(d,transitionDistance<rampStart?rampStart:transitionDistance);
  float maxD=min(d,rampEnd);
  float sd=max(rampEnd,d2);
  float logeLM=1.442695f*LM;
  float expLMd=exp2(logeLM*d);
  float4 fogColor;
  float T0=saturate(exp2(cLM*(expLMd-exp2(logeLM*sd))));
  fogColor.a=T0;
  VolumetricFogLight fragLight;
  fragLight.fFallOff=1.0f;
  fragLight.radialLobe=0.0f;
  fragLight.dotLE=1.0f;
  fragLight.k=0.0f;
  fragLight.k2=1.0f;
  fragLight.cDiffuse=diffuseProbe0.rgb+diffuseProbe1.rgb;
  inscatter+=GetVolumetricFogInscattering(fragLight,true);
  float trns=1.0f;
  fogColor.xyz=0.0f;
  if(rampEnd-rampStart>1.0f&&transitionDistance<rampEnd)
  {
    LM=abs(LM)<0.0001f?0.0001f:LM;
    logeLM=1.442695f*LM;
    float CC=rcp(LM*LM*(rampStart-rampEnd));
    float cCC=-extinctionCoefficient*volFogDensityAtViewer*CC;
    float A0=exp2(logeLM*maxD)*(LM*(rampStart-maxD)+1.0f);
    float A1=exp2(logeLM*minD)*(LM*(rampStart-minD)+1.0f);
    trns=saturate(exp2(cCC*(A0-A1)));
    fogColor.a*=trns;
    float V=exp2(logeLM*rampStart);
    float IE=-exp2(cCC*(A0-V));
    float IS=-exp2(cCC*(A1-V));
    fogColor.xyz+=inscatter*saturate(IE-IS);
  }
  float IE=-T0;
  float IS=-1;
  fogColor.xyz+=trns*inscatter*(IE-IS);
  return fogColor;
}
float4 GetVolumetricFogAnalyticalColor(in VolumetricFogSampling vfs,in float3 cameraToWorldPos,in float lengthToTarget,in bool fullSpan=false)
{
  SVolumetricFogParams params=vfGetVolumetricFogParamsInternal();
  return GetVolumetricFogAnalyticalColor(params,vfs,cameraToWorldPos,lengthToTarget,fullSpan);
}
float4 GetVolumetricFogAnalyticalColor(in float3 cameraToWorldPos,in float lengthToTarget,in bool fullSpan=false)
{
  SVolumetricFogParams params=vfGetVolumetricFogParamsInternal();
  VolumetricFogSampling vfs;
  vfs.volumetricFogTex=VolumetricFogTexture;
  vfs.globalEnvProbeTex0=vfGlobalEnvProbeTexture0;
  vfs.globalEnvProbeTex1=vfGlobalEnvProbeTexture1;
  vfs.trilinearClampSState=vfTrilinearClampSState;
  return GetVolumetricFogAnalyticalColor(params,vfs,cameraToWorldPos,lengthToTarget,fullSpan);
}
float4 GetVolumetricFogAnalyticalColor(in float3 cameraToWorldPos,in bool fullSpan=false)
{
  SVolumetricFogParams params=vfGetVolumetricFogParamsInternal();
  VolumetricFogSampling vfs;
  vfs.volumetricFogTex=VolumetricFogTexture;
  vfs.globalEnvProbeTex0=vfGlobalEnvProbeTexture0;
  vfs.globalEnvProbeTex1=vfGlobalEnvProbeTexture1;
  vfs.trilinearClampSState=vfTrilinearClampSState;
  return GetVolumetricFogAnalyticalColor(params,vfs,cameraToWorldPos,length(cameraToWorldPos),fullSpan);
}
float4 BlendVolumetricFogWithGlobalFog(in SVolumetricFogParams params,in float4 volumetricFog,in float4 globalFog,in VolumetricFogTexcoord vtc)
{
  volumetricFog.xyz=params.fogVisibility*volumetricFog.w*globalFog.xyz+volumetricFog.xyz;
  volumetricFog.a=volumetricFog.w*globalFog.a;
  return volumetricFog;
}
float4 BlendVolumetricFogWithGlobalFog(in float4 volumetricFog,in float4 globalFog,in VolumetricFogTexcoord vtc)
{
  SVolumetricFogParams params=vfGetVolumetricFogParamsInternal();
  return BlendVolumetricFogWithGlobalFog(params,volumetricFog,globalFog,vtc);
}
float4 ClampFinalFogDensity(in SVolumetricFogParams params,in float4 volumetricFog)
{
  volumetricFog.xyz=volumetricFog.xyz*(1.0f-params.clampTransmittance);
  volumetricFog.a=max(volumetricFog.a,params.clampTransmittance);
  return volumetricFog;
}
float4 ClampFinalFogDensity(in float4 volumetricFog)
{
  SVolumetricFogParams params=vfGetVolumetricFogParamsInternal();
  return ClampFinalFogDensity(params,volumetricFog);
}
float GetVolumetricFogDepthTexcoord(in SVolumetricFogParams params,in float linearDepth)
{
  const float c=(2.0f);
  float d=pow(((linearDepth-params.nearDist)*params.invFarMinusNearDist),(1.0f/c));
  d=(0.5f-d)*params.invMaxIndex+d;
  return d;
}
float GetVolumetricFogDepthTexcoord(in float linearDepth)
{
  SVolumetricFogParams params=vfGetVolumetricFogParamsInternal();
  return GetVolumetricFogDepthTexcoord(params,linearDepth);
}
void RectifyVolumetricFogTexcoordAndRangeApproxInternal(in SVolumetricFogParams params,inout VolumetricFogTexcoord vtc)
{
  float2 atc=abs(vtc.texcoord.xy*2.0f-1.0f);
  vtc.range=lerp(lerp(vtc.range,params.farDistCenterLeft,atc.x),lerp(params.farDistTopCenter,params.farDistTopLeft,atc.x),atc.y);
  vtc.texcoord.z=min(vtc.range,vtc.texcoord.z);
}
void RectifyVolumetricFogTexcoordAndRangeInternal(inout VolumetricFogTexcoord vtc,in float lengthToTarget)
{
  float correctionFactor=(vtc.linearDepth/lengthToTarget);
  vtc.range*=correctionFactor;
  vtc.texcoord.z=min(vtc.range,vtc.texcoord.z);
}
VolumetricFogTexcoord GetVolumetricFogTexcoordParamByScreenTexcoordAndDepth(in SVolumetricFogParams params,in float2 screenTC,in float linearDepth,in bool rectifiedRangeApprox=true,in float lengthToTarget=10000000.0f)
{
  VolumetricFogTexcoord vtc;
  vtc.texcoord.xy=screenTC;
  vtc.linearDepth=linearDepth;
  vtc.texcoord.z=vtc.linearDepth;
  vtc.range=params.farDistCenter;
  if(rectifiedRangeApprox)
  {
    RectifyVolumetricFogTexcoordAndRangeApproxInternal(params,vtc);
  }
  else
  {
    RectifyVolumetricFogTexcoordAndRangeInternal(vtc,lengthToTarget);
  }
  vtc.texcoord.z=GetVolumetricFogDepthTexcoord(params,vtc.texcoord.z);
  return vtc;
}
VolumetricFogTexcoord GetVolumetricFogTexcoordParamByScreenTexcoordAndDepth(in float2 screenTC,in float linearDepth,in bool rectifiedRangeApprox=true,in float lengthToTarget=10000000.0f)
{
  SVolumetricFogParams params=vfGetVolumetricFogParamsInternal();
  return GetVolumetricFogTexcoordParamByScreenTexcoordAndDepth(params,screenTC,linearDepth,rectifiedRangeApprox,lengthToTarget);
}
float4 GetVolumetricFogValueJittered(in SVolumetricFogParams params,in VolumetricFogSampling vfs,in VolumetricFogTexcoord vtc)
{
  float3 tc=vtc.texcoord.xyz;
  tc.z=GetJitteredTexcoordDepthInternal(tc.xy*params.screenSize.xy,tc.z,params.invMaxIndex,params.timeParams.xw);
  float4 v=vfs.volumetricFogTex.SampleLevel(vfs.trilinearClampSState,tc.xyz,0.0f);
  return v;
}
float4 GetVolumetricFogValueJittered(in VolumetricFogSampling vfs,in VolumetricFogTexcoord vtc)
{
  SVolumetricFogParams params=vfGetVolumetricFogParamsInternal();
  float3 tc=vtc.texcoord.xyz;
  tc.z=GetJitteredTexcoordDepthInternal(tc.xy*params.screenSize.xy,tc.z,params.invMaxIndex,params.timeParams.xw);
  float4 v=vfs.volumetricFogTex.SampleLevel(vfs.trilinearClampSState,tc.xyz,0.0f);
  return v;
}
float4 GetVolumetricFogValueJittered(in VolumetricFogTexcoord vtc)
{
  SVolumetricFogParams params=vfGetVolumetricFogParamsInternal();
  VolumetricFogSampling vfs;
  vfs.volumetricFogTex=VolumetricFogTexture;
  vfs.trilinearClampSState=vfTrilinearClampSState;
  return GetVolumetricFogValueJittered(params,vfs,vtc);
}
struct vert2fragFog
{
  float4 WPos:SV_POSITION;
  float2 baseTC:TEXCOORD0;
  float3 CamVec:TEXCOORD1;
};
half4 GetZTargetMS(float2 baseTC,int NumSamples,int nCurrSample)
{
  int3 vPixCoord=int3(baseTC*PS_ScreenSize.xy,0);
  return zMapMS.Load(vPixCoord,nCurrSample);
}
float VolFogShadowBilateralFilter(in Texture2D<float2>tex,in SamplerState pointClampSS,in const int numSamples,in const float2 baseTC,in const float refDepth,in const float similarity)
{
  float accumVal=0.0;
  float accumWeight=0.0;
  for(int i=0;
  i<numSamples;
  i++)
  {
    const float2 coord=baseTC.xy+volFogShadowBufSampleOffsets[i].xy;
    const float2 sampleXYZW=tex.Sample(pointClampSS,coord).xy;
    const float sampleVal=sampleXYZW.y;
    const float sampleDepth=sampleXYZW.x;
    const float s=exp2(abs(sampleDepth-refDepth)*-similarity);
    accumVal+=sampleVal*s;
    accumWeight+=s;
  }
  return accumVal/accumWeight;
}
void FogPassCommon(in vert2fragFog IN,in float4 WPos,out float sceneDepth,out float4 localFogColor,out float3 worldPos,out float3 cameraToWorldPos)
{
  float2 sampleUV=MapViewportToRaster(IN.baseTC.xy);
  sceneDepth=GetLinearDepth(zMap,sampleUV);
  cameraToWorldPos=ReconstructWorldPos(WPos.xy,sceneDepth,true);
  worldPos=cameraToWorldPos+vfViewPos.xyz;
  localFogColor=GetVolumetricFogColor(worldPos,cameraToWorldPos);
}
pixout GetSvoGiFog(vert2fragFog IN,pixout OUT)
{
  int nRange=1;
  float fDepthRange=0.2f;
  float fDepth0=GetLinearDepth(zMap,IN.baseTC.xy);
  float2 vSrcPixSize=1.f/PS_ScreenSize.xy*SVO_AirTextureScale.xy;
  float4 vAir=0;
  float fSumm=0;
  for(int x=-nRange;
  x<=nRange;
  x+=1)for(int y=-nRange;
  y<=nRange;
  y+=1)
  {
    float fLen=max(0,1+nRange-sqrt(x*x+y*y));
    float2 tc1=IN.baseTC.xy+float2(x,y)*vSrcPixSize;
    
    {
      float fDepth1=GetTexture2D(FOG_smp_Air_Depths,FOG_SStatePC,tc1).r;
      float fW=fLen*(abs(1.f-fDepth1/fDepth0)<fDepthRange)+0.001f;
      vAir+=GetTexture2D(FOG_smp_Air_RGBA_Min,FOG_SStatePC,tc1)*fW;
      fSumm+=fW;
    }
    
    {
      float fDepth1=GetTexture2D(FOG_smp_Air_Depths,FOG_SStatePC,tc1).g;
      float fW=fLen*(abs(1.f-fDepth1/fDepth0)<fDepthRange)+0.001f;
      vAir+=GetTexture2D(FOG_smp_Air_RGBA_Max,FOG_SStatePC,tc1)*fW;
      fSumm+=fW;
    }
    }
  vAir/=fSumm;
  OUT.Color=vAir*vAir.a;
  OUT.Color.a=vAir.a;
  OUT.Color.a=saturate(1.0f-OUT.Color.a);
  return OUT;
}
float4 GetVolumetricFog(in vert2fragFog IN,in float4 WPos)
{
  float sceneDepth;
  sceneDepth=GetLinearDepth(zMap,IN.baseTC.xy);
  float linearDepth=sceneDepth*PS_NearFarClipDist.y;
  float3 cameraToWorldPos=ReconstructWorldPos(WPos.xy,sceneDepth,true);
  VolumetricFogSampling vfs;
  vfs.volumetricFogTex=volFogSamplingTex;
  vfs.globalEnvProbeTex0=volFogGlobalEnvProbeTex0;
  vfs.globalEnvProbeTex1=volFogGlobalEnvProbeTex1;
  vfs.trilinearClampSState=volFogTrilinearClampSState;
  float len=length(cameraToWorldPos);
  VolumetricFogTexcoord vtc=GetVolumetricFogTexcoordParamByScreenTexcoordAndDepth(IN.baseTC.xy,linearDepth,false,len);
  float4 vf=GetVolumetricFogValueJittered(vfs,vtc);
  float4 localFogColor=GetVolumetricFogAnalyticalColor(vfs,cameraToWorldPos,len);
  localFogColor=BlendVolumetricFogWithGlobalFog(vf,localFogColor,vtc);
  localFogColor=ClampFinalFogDensity(localFogColor);
  return localFogColor;
}
pixout FogPassPS(vert2fragFog IN)
{
  pixout OUT;
  float4 localFogColor;
  float sceneDepth;
  float3 worldPos,cameraToWorldPos;
  FogPassCommon(IN,IN.WPos,sceneDepth,localFogColor,worldPos,cameraToWorldPos);
  localFogColor.a=saturate(1.0-localFogColor.a);
  localFogColor.xyz*=localFogColor.a;
  localFogColor.a=saturate(1.0-localFogColor.a);
  HDROutput(OUT,localFogColor,1);
  return OUT;
}