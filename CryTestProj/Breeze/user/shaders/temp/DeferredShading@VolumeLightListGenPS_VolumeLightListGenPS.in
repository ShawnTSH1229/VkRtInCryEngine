/*
BgAAAHBzXzZfMAAAFAAAAFZvbHVtZUxpZ2h0TGlzdEdlblBTAwIQAAAAwEAQAAAAwEEDEQAAAEBAEQAAAEBBEQAAAEBDAREAAAAAQAAAAAAAAAAA
*/

cbuffer PER_BATCH:register(b0, space2)
{
  float4 irreg_kernel_2d[16/2];
};
Texture2D<float4>DepthTex:register(t2, space1);
cbuffer CBPerViewGlobal:register(b6)
{
  float4x4 CV_ViewProjZeroMatr;
  float4 CV_AnimGenParams;
  float4x4 CV_ViewProjMatr;
  float4x4 CV_ViewProjNearestMatr;
  float4x4 CV_InvViewProj;
  float4x4 CV_PrevViewProjMatr;
  float4x4 CV_PrevViewProjNearestMatr;
  float3x4 CV_ScreenToWorldBasis;
  float4 CV_TessInfo;
  float4 CV_WorldViewPosition;
  float4 CV_CameraRightVector;
  float4 CV_CameraFrontVector;
  float4 CV_CameraUpVector;
  float4 CV_ScreenSize;
  float4 CV_HPosScale;
  float4 CV_ProjRatio;
  float4 CV_NearestScaled;
  float4 CV_NearFarClipDist;
  float4 CV_SunLightDir;
  float4 CV_SunColor;
  float4 CV_SkyColor;
  float4 CV_FogColor;
  float4 CV_TerrainInfo;
  float4 CV_DecalZFightingRemedy;
  float4x4 CV_FrustumPlaneEquation;
  float4 CV_WindGridOffset;
  float4x4 CV_ViewMatr;
  float4x4 CV_InvViewMatr;
  float4x4 CV_ProjMatr;
  float4x4 CV_ProjMatrUnjittered;
};
cbuffer CBPerPassShadowGen:register(b5)
{
  float4 CP_ShadowGen_LightPos;
  float4 CP_ShadowGen_ViewPos;
  float4 CP_ShadowGen_DepthTestBias;
  float4 CP_ShadowGen_FrustumInfo;
  float4 CP_ShadowGen_VegetationAlphaClamp;
};
cbuffer CBPerPassCustom:register(b5)
{
  float4 CP_Custom_ViewMode;
};
cbuffer CB_SkinQuat_Cur:register(b2)
{
  float2x4 _g_SkinQuat_Cur[768];
};
cbuffer CB_SkinQuat_Prev:register(b3)
{
  float2x4 _g_SkinQuat_Prev[768];
};
float4 CalcHomogeneousPos(float SceneDepth,float2 WPos,float4 worldBasisX,float4 worldBasisY,float4 worldBasisZ)
{
  float4 HPos=worldBasisZ.xyzw+(worldBasisX.xyzw*WPos.x)+(worldBasisY.xyzw*WPos.y);
  HPos.xyzw*=SceneDepth.xxxx;
  return HPos;
}
cbuffer CBDeferredDecal:register(b0, space2)
{
  struct
  {
    float4x4 matVolumeProj;
    float4x4 matInvVolumeProj;
    float4x4 matDecalTS;
    float4 textureRect[2];
    float4 diffuseCol;
    float4 specularCol;
    float4 mipLevels;
    float4 generalParams;
    float4 opacityParams;
  }
  cbDecal;
};
cbuffer CBSSDO:register(b0, space2)
{
  struct SSDOConstants
  {
    float4 screenSize;
    float4 nearFarClipDist;
    float4 viewSpaceParams;
    float4 ssdoParams;
    float4 hmaoParams;
  }
  cbSSDO;
};
cbuffer CBClipVolume:register(b0, space2)
{
  struct ClipVolumeConstants
  {
    float4x4 transformMatrix;
    float4 projRatioScreenScale;
    float4 blendPlane0;
    float4 blendPlane1;
  }
  cbClipVolume;
};
cbuffer CBClipVolumeVolFog:register(b0, space2)
{
  struct ClipVolumeVolFogConstants
  {
    float4x4 transformMatrix;
    uint4 sliceIndex;
  }
  cbClipVolumeVolFog;
};
cbuffer CBShadowMask:register(b0, space2)
{
  struct ShadowMaskConstants
  {
    float4x4 unitMeshTransform;
    float4 lightVolumeSphereAdjust;
    float4x4 lightShadowProj;
    float4 params;
    float4 irreg_kernel_2d[8];
    float4 vLightPos;
  }
  cbShadowMaskConstants;
};
struct STiledLightVolumeInfo
{
  float4x4 worldMat;
  float4 volumeTypeInfo;
  float4 volumeParams0;
  float4 volumeParams1;
  float4 volumeParams2;
  float4 volumeParams3;
};
groupshared uint sTileLightIndices[255];
groupshared uint sTileLightMask[8];
groupshared uint sTileLightMaskCounts[8];
RWBuffer<uint>VolumeOpaqueLightMaskUAV:register(u0, space0);
RWBuffer<uint>VolumeTranspLightMaskUAV:register(u1, space0);
StructuredBuffer<STiledLightVolumeInfo>TiledLightsVolumeInfo:register(t1, space1);
cbuffer CBVolumeLightListGen:register(b0, space2)
{
  struct
  {
    float4x4 matViewProj;
    uint lightIndexOffset;
    uint numVertices;
    float4 screenScale;
    float4 viewerPos;
    float4 worldBasisX;
    float4 worldBasisY;
    float4 worldBasisZ;
  }
  cbVolumeLightListGen;
};
struct vtxOutVolumeLightListGen
{
  float4 WPos:SV_Position;
  nointerpolation uint lightIndex:TEXCOORD0;
};
[earlydepthstencil]void VolumeLightListGenPS(vtxOutVolumeLightListGen IN,bool bIsFrontFace:SV_IsFrontFace)
{
  const uint lightIndex=IN.lightIndex;
  const uint2 pixelPos=IN.WPos.xy;
  float2 depthMaxMin=DepthTex.Load(int3(pixelPos.xy,0)).xy;
  float3 positionMax=CalcHomogeneousPos(1,pixelPos.xy,cbVolumeLightListGen.worldBasisX,cbVolumeLightListGen.worldBasisY,cbVolumeLightListGen.worldBasisZ);
  float3 positionMin=CalcHomogeneousPos(0,pixelPos.xy,cbVolumeLightListGen.worldBasisX,cbVolumeLightListGen.worldBasisY,cbVolumeLightListGen.worldBasisZ);
  STiledLightVolumeInfo volume=TiledLightsVolumeInfo[lightIndex];
  uint volumeType=volume.volumeTypeInfo.x;
  uint lightId=volume.volumeTypeInfo.w;
  uint2 numTiles=(uint2)cbVolumeLightListGen.screenScale.xy;
  uint tileIdx=pixelPos.y*numTiles.x+pixelPos.x;
  uint bufferBaseIdx=tileIdx*8;
  bool bInVolume=(volumeType==4)?true:false;
  bool bInTranspVolume=bInVolume;
  if(volumeType==3)
  {
    float3 volumePos=float3(volume.volumeParams0.w,volume.volumeParams1.w,volume.volumeParams2.w)-cbVolumeLightListGen.viewerPos;
    float3 posMinLS=mul(float3x3(volume.volumeParams0.xyz,volume.volumeParams1.xyz,volume.volumeParams2.xyz),volumePos-positionMin.xyz);
    float3 posMaxLS=mul(float3x3(volume.volumeParams0.xyz,volume.volumeParams1.xyz,volume.volumeParams2.xyz),volumePos-positionMax.xyz);
    float3 rayOrig=posMinLS;
    float3 rayDir=normalize(posMaxLS-posMinLS);
    float3 rcpDir=rcp(rayDir);
    float3 tneg=(-volume.volumeParams3.xyz-rayOrig)*rcpDir;
    float3 tpos=(volume.volumeParams3.xyz-rayOrig)*rcpDir;
    float3 tmin=min(tneg,tpos);
    float3 tmax=max(tneg,tpos);
    float t0=max(max(tmin.x,tmin.y),tmin.z);
    float t1=min(min(tmax.x,tmax.y),tmax.z);
    if(t0<=t1)
    {
      positionMin=CalcHomogeneousPos(depthMaxMin.y,pixelPos.xy,cbVolumeLightListGen.worldBasisX,cbVolumeLightListGen.worldBasisY,cbVolumeLightListGen.worldBasisZ);
      positionMax=CalcHomogeneousPos(depthMaxMin.x,pixelPos.xy,cbVolumeLightListGen.worldBasisX,cbVolumeLightListGen.worldBasisY,cbVolumeLightListGen.worldBasisZ);
      posMinLS=mul(float3x3(volume.volumeParams0.xyz,volume.volumeParams1.xyz,volume.volumeParams2.xyz),volumePos-positionMin.xyz);
      posMaxLS=mul(float3x3(volume.volumeParams0.xyz,volume.volumeParams1.xyz,volume.volumeParams2.xyz),volumePos-positionMax.xyz);
      if(t0<=length(posMaxLS-rayOrig))
      {
        bInTranspVolume=true;
        if(t1>=length(posMinLS-rayOrig))bInVolume=true;
      }
      }
    }
  else if(volumeType==2)
  {
    positionMin=CalcHomogeneousPos(depthMaxMin.y,pixelPos.xy,cbVolumeLightListGen.worldBasisX,cbVolumeLightListGen.worldBasisY,cbVolumeLightListGen.worldBasisZ);
    positionMax=CalcHomogeneousPos(depthMaxMin.x,pixelPos.xy,cbVolumeLightListGen.worldBasisX,cbVolumeLightListGen.worldBasisY,cbVolumeLightListGen.worldBasisZ);
    float3 forwardVec=volume.volumeParams1.xyz;
    float3 upVector=abs(forwardVec.z)<0.999?float3(0,0,1):float3(1,0,0);
    float3 tangentX=normalize(cross(upVector,forwardVec));
    float3 tangentY=cross(forwardVec,tangentX);
    float cosFOV=volume.volumeTypeInfo.z;
    float sinFOV=volume.volumeTypeInfo.y;
    float3 N0=tangentX*cosFOV-forwardVec*sinFOV;
    float3 N1=-tangentX*cosFOV-forwardVec*sinFOV;
    float3 N2=tangentY*cosFOV-forwardVec*sinFOV;
    float3 N3=-tangentY*cosFOV-forwardVec*sinFOV;
    const float3 P0=volume.volumeParams0.xyz-cbVolumeLightListGen.viewerPos;
    bInVolume=dot(-volume.volumeParams1.xyz,positionMin-P0)>=0||dot(-volume.volumeParams1.xyz,positionMax-P0)>=0;
    if(dot(N0,positionMin-P0)<0&&dot(N0,positionMax-P0)<0)bInVolume=false;
    if(dot(N1,positionMin-P0)<0&&dot(N1,positionMax-P0)<0)bInVolume=false;
    if(dot(N2,positionMin-P0)<0&&dot(N2,positionMax-P0)<0)bInVolume=false;
    if(dot(N3,positionMin-P0)<0&&dot(N3,positionMax-P0)<0)bInVolume=false;
    float3 P1=P0-volume.volumeParams1.xyz*volume.volumeParams0.w;
    if(dot(volume.volumeParams1.xyz,positionMin-P1)<0&&dot(volume.volumeParams1.xyz,positionMax-P1)<0)bInVolume=false;
    bInTranspVolume=true;
  }
  else if(volumeType==1)
  {
    float3 rayOrig=positionMin;
    float3 rayDir=normalize(positionMax-positionMin);
    float3 volumePos=volume.volumeParams0.xyz-cbVolumeLightListGen.viewerPos;
    float3 v=volumePos-rayOrig;
    float b=dot(v,rayDir);
    float radius2=volume.volumeParams0.w*volume.volumeParams0.w;
    float d2=radius2-(dot(v,v)-b*b);
    if(d2>=0)
    {
      float t0=b-sqrt(d2);
      float t1=b+sqrt(d2);
      positionMin=CalcHomogeneousPos(depthMaxMin.y,pixelPos.xy,cbVolumeLightListGen.worldBasisX,cbVolumeLightListGen.worldBasisY,cbVolumeLightListGen.worldBasisZ);
      bInTranspVolume=true;
      if(t1>=length(positionMin-rayOrig))bInVolume=true;
    }
    }
  uint maskIndex=lightId/32;
  [branch]if(bInTranspVolume)InterlockedOr(VolumeTranspLightMaskUAV[bufferBaseIdx+maskIndex],1<<(lightId&31));
  [branch]if(bInVolume)InterlockedOr(VolumeOpaqueLightMaskUAV[bufferBaseIdx+maskIndex],1<<(lightId&31));
}