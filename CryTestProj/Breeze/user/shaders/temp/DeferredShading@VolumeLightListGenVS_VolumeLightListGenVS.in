/*
BgAAAHZzXzZfMAAAFAAAAFZvbHVtZUxpZ2h0TGlzdEdlblZTAwIQAAAAwEAQAAAAwEEDEQAAAEBAEQAAAEBBEQAAAEBDAREAAAAAQAAAAAAAAAAA
*/

cbuffer PER_BATCH:register(b0, space2)
{
  float4 irreg_kernel_2d[16/2];
};
cbuffer CBPerViewGlobal:register(b6)
{
  float4x4 CV_ViewProjZeroMatr;
  float4 CV_AnimGenParams;
  float4x4 CV_ViewProjMatr;
  float4x4 CV_ViewProjNearestMatr;
  float4x4 CV_InvViewProj;
  float4x4 CV_PrevViewProjMatr;
  float4x4 CV_PrevViewProjNearestMatr;
  float3x4 CV_ScreenToWorldBasis;
  float4 CV_TessInfo;
  float4 CV_WorldViewPosition;
  float4 CV_CameraRightVector;
  float4 CV_CameraFrontVector;
  float4 CV_CameraUpVector;
  float4 CV_ScreenSize;
  float4 CV_HPosScale;
  float4 CV_ProjRatio;
  float4 CV_NearestScaled;
  float4 CV_NearFarClipDist;
  float4 CV_SunLightDir;
  float4 CV_SunColor;
  float4 CV_SkyColor;
  float4 CV_FogColor;
  float4 CV_TerrainInfo;
  float4 CV_DecalZFightingRemedy;
  float4x4 CV_FrustumPlaneEquation;
  float4 CV_WindGridOffset;
  float4x4 CV_ViewMatr;
  float4x4 CV_InvViewMatr;
  float4x4 CV_ProjMatr;
  float4x4 CV_ProjMatrUnjittered;
};
cbuffer CBPerPassShadowGen:register(b5)
{
  float4 CP_ShadowGen_LightPos;
  float4 CP_ShadowGen_ViewPos;
  float4 CP_ShadowGen_DepthTestBias;
  float4 CP_ShadowGen_FrustumInfo;
  float4 CP_ShadowGen_VegetationAlphaClamp;
};
cbuffer CBPerPassCustom:register(b5)
{
  float4 CP_Custom_ViewMode;
};
cbuffer CB_SkinQuat_Cur:register(b2)
{
  float2x4 _g_SkinQuat_Cur[768];
};
cbuffer CB_SkinQuat_Prev:register(b3)
{
  float2x4 _g_SkinQuat_Prev[768];
};
cbuffer CBDeferredDecal:register(b0, space2)
{
  struct
  {
    float4x4 matVolumeProj;
    float4x4 matInvVolumeProj;
    float4x4 matDecalTS;
    float4 textureRect[2];
    float4 diffuseCol;
    float4 specularCol;
    float4 mipLevels;
    float4 generalParams;
    float4 opacityParams;
  }
  cbDecal;
};
cbuffer CBSSDO:register(b0, space2)
{
  struct SSDOConstants
  {
    float4 screenSize;
    float4 nearFarClipDist;
    float4 viewSpaceParams;
    float4 ssdoParams;
    float4 hmaoParams;
  }
  cbSSDO;
};
cbuffer CBClipVolume:register(b0, space2)
{
  struct ClipVolumeConstants
  {
    float4x4 transformMatrix;
    float4 projRatioScreenScale;
    float4 blendPlane0;
    float4 blendPlane1;
  }
  cbClipVolume;
};
cbuffer CBClipVolumeVolFog:register(b0, space2)
{
  struct ClipVolumeVolFogConstants
  {
    float4x4 transformMatrix;
    uint4 sliceIndex;
  }
  cbClipVolumeVolFog;
};
cbuffer CBShadowMask:register(b0, space2)
{
  struct ShadowMaskConstants
  {
    float4x4 unitMeshTransform;
    float4 lightVolumeSphereAdjust;
    float4x4 lightShadowProj;
    float4 params;
    float4 irreg_kernel_2d[8];
    float4 vLightPos;
  }
  cbShadowMaskConstants;
};
struct STiledLightVolumeInfo
{
  float4x4 worldMat;
  float4 volumeTypeInfo;
  float4 volumeParams0;
  float4 volumeParams1;
  float4 volumeParams2;
  float4 volumeParams3;
};
groupshared uint sTileLightIndices[255];
groupshared uint sTileLightMask[8];
groupshared uint sTileLightMaskCounts[8];
Buffer<float4>VolumeVertexData:register(t0, space1);
StructuredBuffer<STiledLightVolumeInfo>TiledLightsVolumeInfo:register(t1, space1);
cbuffer CBVolumeLightListGen:register(b0, space2)
{
  struct
  {
    float4x4 matViewProj;
    uint lightIndexOffset;
    uint numVertices;
    float4 screenScale;
    float4 viewerPos;
    float4 worldBasisX;
    float4 worldBasisY;
    float4 worldBasisZ;
  }
  cbVolumeLightListGen;
};
struct vtxOutVolumeLightListGen
{
  float4 WPos:SV_Position;
  nointerpolation uint lightIndex:TEXCOORD0;
};
vtxOutVolumeLightListGen VolumeLightListGenVS(uint VertexID:SV_VertexID)
{
  vtxOutVolumeLightListGen OUT=(vtxOutVolumeLightListGen)0;
  const uint numVertices=cbVolumeLightListGen.numVertices;
  const uint vertexIndex=VertexID % numVertices;
  const uint lightIndex=VertexID/numVertices+cbVolumeLightListGen.lightIndexOffset;
  float4 pos=VolumeVertexData[vertexIndex];
  pos=mul(pos,TiledLightsVolumeInfo[lightIndex].worldMat);
  pos=mul(pos,cbVolumeLightListGen.matViewProj);
  OUT.WPos=pos;
  OUT.lightIndex=lightIndex;
  return OUT;
}